# Isaac Sim 与训练模块接口设计文档（方案B：Flask 服务器中转）

本文档详细设计 Isaac Sim 仿真环境与 HIL-SERL 训练系统的接口，基于**方案B：Flask 服务器中转**架构。

**实现方案**：方案B - 使用 Flask 服务器作为消息中转节点

- ✅ 使用 `omni.isaac.kit.SimulationApp` 启动 Isaac Sim
- ✅ 使用 `omni.isaac.core.World` 等原生 API
- ✅ **使用 Flask 服务器作为消息中转，保持与原项目架构一致**
- ✅ **支持仿真环境和策略分离部署（两台主机）**
- ✅ **解决观察状态延迟问题，确保控制命令基于最新状态**

## 目录

1. [系统架构概览](#系统架构概览)
2. [代码复用性分析](#代码复用性分析)
3. [Flask 服务器接口设计](#flask-服务器接口设计)
4. [Gym 环境接口设计](#gym-环境接口设计)
5. [接口规范参考](#接口规范参考)
6. [待确认事项](#待确认事项)
7. [数据采集接口](#数据采集接口)
8. [训练接口](#训练接口)
9. [数据同步接口](#数据同步接口)
10. [延迟优化接口](#延迟优化接口)
11. [实现示例](#实现示例)
12. [接口兼容性总结](#接口兼容性总结)

---

## 系统架构概览

### 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        HIL-SERL 完整系统架构                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          仿真环境模块 (主机1)                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Isaac Sim Flask Server                          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  ┌──────────────┐         ┌──────────────┐         ┌──────────┐  │   │
│  │  │  Flask App   │         │ IsaacSimServer│         │ Isaac Sim │  │   │
│  │  │              │         │              │         │ Simulation│  │   │
│  │  │ - HTTP路由   │◄───────►│ - 仿真管理   │◄───────►│           │  │   │
│  │  │ - 请求处理   │         │ - 状态更新   │         │ - 物理引擎│  │   │
│  │  │ - JSON响应   │         │ - 机器人控制 │         │ - 渲染引擎│  │   │
│  │  └──────┬───────┘         └──────────────┘         └──────────┘  │   │
│  │         │                                                          │   │
│  │         │ HTTP POST/GET                                            │   │
│  │         │ (控制命令/状态查询)                                       │   │
│  └─────────┼──────────────────────────────────────────────────────────┘   │
│            │                                                                 │
└────────────┼───────────────────────────────────────────────────────────────┘
             │
             │ 网络 (HTTP)
             │
┌────────────┼───────────────────────────────────────────────────────────────┐
│            │                    RL 训练模块 (主机2)                          │
├────────────┼───────────────────────────────────────────────────────────────┤
│            │                                                                 │
│  ┌─────────▼──────────┐         ┌──────────────────┐                      │
│  │   Gym Environment │         │   Actor 进程      │                      │
│  │                    │         │                   │                      │
│  │ IsaacSimFrankaEnv  │         │ - 环境交互        │                      │
│  │                    │         │ - 数据收集        │                      │
│  │ - step()           │◄───────►│ - 策略执行        │                      │
│  │ - reset()          │         │ - 干预记录        │                      │
│  │ - _get_obs()       │         │                   │                      │
│  └─────────┬──────────┘         └─────────┬────────┘                      │
│            │                                │                                │
│            │                                │                                │
│  ┌─────────▼────────────────────────────────▼──────────┐                  │
│  │              TrainerClient                             │                  │
│  │              (agentlace)                              │                  │
│  │  - 数据发送到 Learner                                 │                  │
│  │  - 接收参数更新                                       │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
│                          │ 网络通信 (TCP/IP)                                │
│                          │                                                  │
│  ┌───────────────────────▼───────────────────────────────┐                  │
│  │              TrainerServer                             │                  │
│  │              (agentlace)                               │                  │
│  │  - 接收 Actor 数据                                     │                  │
│  │  - 发布参数更新                                       │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
│  ┌───────────────────────▼───────────────────────────────┐                  │
│  │              Learner 进程                              │                  │
│  │                                                         │                  │
│  │  - 模型训练 (SAC Agent)                                │                  │
│  │  - 参数更新                                            │                  │
│  │  - 检查点保存                                          │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
└──────────────────────────┼──────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          数据存储模块                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────┐         ┌──────────────────┐         ┌──────────┐   │
│  │ QueuedDataStore  │         │ ReplayBuffer     │         │ 磁盘存储  │   │
│  │  (Actor 端)      │         │ DataStore        │         │          │   │
│  │                  │         │ (Learner 端)     │         │ - buffer/│   │
│  │ - 在线经验队列    │────────►│                  │◄────────│ - demo_  │   │
│  │ - 干预数据队列    │  网络   │ - 在线经验缓冲区  │  持久化  │   buffer/│   │
│  │                  │         │ - 演示数据缓冲区  │         │          │   │
│  └──────────────────┘         └──────────────────┘         └──────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 实现方案（方案B：Flask 服务器中转）

**方案选择**：使用 Flask 服务器作为消息中转节点，保持与原项目架构一致

**架构对比**：

| 组件 | 原项目（真机） | 方案B（仿真） |
|------|---------------|---------------|
| **通信方式** | HTTP POST 请求 | HTTP POST 请求（保持一致） |
| **服务器** | Flask Server（独立进程） | Flask Server（独立进程，保持一致） |
| **机器人控制** | ROS1 消息 | Isaac Sim API |
| **相机** | RealSense 硬件 | Isaac Sim 虚拟相机 |
| **环境启动** | 外部启动 Flask | 外部启动 Flask（保持一致） |
| **部署方式** | 单机或分离 | **支持分离部署（两台主机）** |

**关键特点**：
- ✅ Flask 服务器作为独立进程运行，管理 Isaac Sim 生命周期
- ✅ Gym 环境通过 HTTP 请求与 Flask 服务器通信
- ✅ 接口与原项目 `franka_server.py` 完全一致
- ✅ 支持双机部署（仿真主机 + 训练主机）
- ✅ 优化观察状态延迟，确保控制命令基于最新状态

### 关键组件

1. **Isaac Sim Flask Server**：独立进程，管理仿真环境和 HTTP 接口
2. **Gym Environment Interface**：标准化的环境接口（`reset`, `step`, `observation_space`, `action_space`）
3. **HTTP Client**：Gym 环境中的 HTTP 客户端（`requests`）
4. **Data Collection**：数据采集模块（演示、分类器数据）
5. **Training Pipeline**：训练流程（Actor-Learner 架构）
6. **Data Synchronization**：数据同步机制（DataStore, TrainerClient/Server）

---

## 代码复用性分析

### 1. 完全复用的模块

以下模块**完全不需要修改**，可以直接复用：

#### 1.1 训练相关模块

| 模块 | 路径 | 说明 |
|------|------|------|
| **训练脚本** | `examples/train_rlpd.py` | Actor-Learner 训练流程，完全复用 |
| **训练脚本** | `examples/train_bc.py` | BC 训练脚本，完全复用 |
| **训练脚本** | `examples/train_hgdagger.py` | HG-DAgger 训练脚本，完全复用 |
| **训练脚本** | `examples/train_reward_classifier.py` | 奖励分类器训练，完全复用 |
| **Agent 实现** | `serl_launcher/serl_launcher/agents/` | SAC、BC 等智能体实现，完全复用 |
| **网络结构** | `serl_launcher/serl_launcher/networks/` | 神经网络结构，完全复用 |
| **数据管理** | `serl_launcher/serl_launcher/data/` | ReplayBuffer、DataStore，完全复用 |
| **训练工具** | `serl_launcher/serl_launcher/utils/` | 训练工具函数，完全复用 |
| **Vision 模块** | `serl_launcher/serl_launcher/vision/` | 视觉编码器，完全复用 |
| **Wrappers** | `serl_launcher/serl_launcher/wrappers/` | Gym 环境包装器，完全复用 |

#### 1.2 数据采集模块

| 模块 | 路径 | 说明 |
|------|------|------|
| **演示数据采集** | `examples/record_demos.py` | 演示数据采集脚本，完全复用 |
| **分类器数据采集** | `examples/record_success_fail.py` | 成功/失败数据采集，完全复用 |

#### 1.3 数据管理模块

| 模块 | 路径 | 说明 |
|------|------|------|
| **DataStore** | `serl_launcher/serl_launcher/data/data_store.py` | 数据存储接口，完全复用 |
| **ReplayBuffer** | `serl_launcher/serl_launcher/data/replay_buffer.py` | 经验回放缓冲区，完全复用 |
| **TrainerClient/Server** | `agentlace.trainer` | 训练器通信，完全复用 |

#### 1.4 工具模块

| 模块 | 路径 | 说明 |
|------|------|------|
| **旋转工具** | `serl_robot_infra/franka_env/utils/rotations.py` | 旋转转换工具，完全复用 |
| **变换工具** | `serl_robot_infra/franka_env/utils/transformations.py` | 坐标变换工具，完全复用 |
| **环境包装器** | `serl_robot_infra/franka_env/envs/wrappers.py` | 环境包装器，完全复用 |
| **相对坐标系** | `serl_robot_infra/franka_env/envs/relative_env.py` | 相对坐标系包装器，完全复用 |

#### 1.5 配置模块

| 模块 | 路径 | 说明 |
|------|------|------|
| **实验配置** | `examples/experiments/*/config.py` | 实验配置文件，完全复用（只需修改 `SERVER_URL`） |
| **配置映射** | `examples/experiments/mappings.py` | 配置映射，完全复用 |

**复用原因**：
- 这些模块只依赖 Gym 环境接口，不依赖具体的机器人实现
- 只要环境实现了标准的 `reset()` 和 `step()` 接口，这些模块就可以正常工作
- 数据管理、训练流程、智能体实现都是环境无关的

### 2. 需要修改的模块

以下模块需要**部分修改**，以适应 Isaac Sim 环境：

#### 2.1 Gym 环境模块

| 模块 | 路径 | 修改内容 | 修改程度 |
|------|------|---------|---------|
| **环境基类** | `serl_robot_infra/franka_env/envs/franka_env.py` | 创建新的 `IsaacSimFrankaEnv` 类，继承或参考 `FrankaEnv` | **新增类** |
| **环境初始化** | `examples/experiments/*/config.py` | 在 `get_environment()` 中添加 Isaac Sim 环境选项 | **小修改** |

**修改说明**：
- `FrankaEnv` 类通过 HTTP 请求与 Flask 服务器通信，这个机制可以完全复用
- 需要创建 `IsaacSimFrankaEnv` 类，实现相同的接口，但连接到 Isaac Sim Flask 服务器
- 配置文件中需要添加选择环境的逻辑（真机 vs 仿真）

#### 2.2 配置文件

| 模块 | 路径 | 修改内容 | 修改程度 |
|------|------|---------|---------|
| **环境配置** | `examples/experiments/*/config.py` | 添加 `SERVER_URL` 配置（指向 Isaac Sim Flask 服务器） | **小修改** |

**修改说明**：
- 只需修改 `SERVER_URL` 从真机 Flask 服务器改为 Isaac Sim Flask 服务器
- 其他配置（动作空间、观察空间、奖励阈值等）完全不变

### 3. 需要新增的模块

以下模块需要**完全新增**：

#### 3.1 Isaac Sim Flask 服务器

| 模块 | 路径 | 说明 |
|------|------|------|
| **Flask 服务器** | `serl_robot_infra/robot_servers/isaac_sim_server.py` | **新增**：Isaac Sim Flask 服务器 |

**新增原因**：
- 原项目有 `franka_server.py`（ROS1 + Flask），但 Isaac Sim 需要新的实现
- 需要管理 Isaac Sim 的生命周期（启动、运行、关闭）
- 需要实现与原项目相同的 HTTP 接口

#### 3.2 Isaac Sim 环境类

| 模块 | 路径 | 说明 |
|------|------|------|
| **环境类** | `serl_robot_infra/franka_env/envs/isaac_sim_env.py` | **新增**：Isaac Sim 环境实现（如果不存在） |

**新增原因**：
- 需要实现与 `FrankaEnv` 相同的接口
- 通过 HTTP 请求与 Isaac Sim Flask 服务器通信
- 处理图像传输、状态查询等

### 4. 代码复用统计

| 类别 | 模块数量 | 复用比例 |
|------|---------|---------|
| **完全复用** | ~20+ 个模块 | **~90%** |
| **需要修改** | 2 个模块 | **~5%** |
| **需要新增** | 2 个模块 | **~5%** |

**结论**：代码复用率非常高，只需要新增 2 个模块，修改 2 个模块，其他所有代码都可以直接复用。

---

## Flask 服务器接口设计

### 1. Isaac Sim Flask Server 模块功能设计

#### 1.1 模块定位

**Isaac Sim Flask Server** 是一个独立进程，作为仿真环境与训练模块之间的**消息中转节点**。

**核心职责**：
1. **Isaac Sim 应用管理**：启动、运行、关闭 Isaac Sim 仿真环境
2. **机器人控制接口**：接收控制命令，转换为 Isaac Sim API 调用
3. **状态查询接口**：提供机器人状态查询（位姿、速度、力/力矩等）
4. **图像传输接口**：提供相机图像获取（支持多相机）
5. **HTTP 服务**：提供 RESTful API，与原项目 `franka_server.py` 接口一致

#### 1.2 功能详细描述

##### 功能1：Isaac Sim 应用管理

**功能描述**：
- **启动管理**：在服务器启动时初始化 Isaac Sim（`SimulationApp`）
- **生命周期管理**：管理 Isaac Sim 的完整生命周期（启动 → 运行 → 关闭）
- **场景管理**：创建和管理仿真场景（世界、机器人、相机、任务对象）
- **物理引擎管理**：配置和运行物理引擎（60 Hz 步进频率）
- **渲染管理**：管理渲染引擎（支持无头模式和有头模式）

**关键设计**：
- 使用单例模式管理 `SimulationApp`（只能启动一次）
- 在独立线程中运行仿真循环，避免阻塞 HTTP 请求
- 支持优雅关闭（清理资源）

**与原项目对比**：
- 原项目：管理 ROS1 节点和阻抗控制器
- Isaac Sim：管理 `SimulationApp` 和物理引擎

##### 功能2：机器人控制接口

**功能描述**：
- **位姿控制**：接收末端执行器目标位姿（xyz + 四元数），转换为关节目标
- **IK 求解**：实现逆运动学求解，将笛卡尔空间位姿转换为关节空间目标
- **关节控制**：设置机器人关节目标位置/速度
- **夹爪控制**：控制夹爪开合（支持二进制和连续控制）
- **命令队列**：管理控制命令队列，确保命令按顺序执行

**关键设计**：
- 需要实现 IK 求解器（可以使用 Isaac Sim 的控制器或自定义实现）
- 命令执行需要与物理步进同步
- 支持命令超时和丢弃机制

**与原项目对比**：
- 原项目：通过 ROS1 发布到 `/cartesian_impedance_controller/equilibrium_pose`
- Isaac Sim：通过 Isaac Sim API 设置关节目标

##### 功能3：状态查询接口

**功能描述**：
- **状态缓存**：持续更新机器人状态（位姿、速度、力/力矩、关节状态等）
- **快速查询**：提供低延迟的状态查询接口
- **线程安全**：使用锁保护共享状态，确保数据一致性
- **状态快照**：提供状态快照机制，确保查询时获取一致的状态

**关键设计**：
- 状态在仿真循环中持续更新（不加锁，快速更新）
- 查询时加锁获取状态快照（确保一致性）
- 参考原项目的状态更新机制

**状态包括**：
- 末端执行器位姿（xyz + 四元数）
- 末端执行器速度（6 维）
- 末端执行器力/力矩（6 维）
- 关节位置/速度（7 维）
- 雅可比矩阵（6x7）
- 夹爪位置（1 维）

**与原项目对比**：
- 原项目：从 ROS1 订阅 `franka_state_controller/franka_states` 消息
- Isaac Sim：从 Isaac Sim API 获取状态（USD API 或 Isaac Sim API）

##### 功能4：图像传输接口

**功能描述**：
- **图像采集**：从 Isaac Sim 虚拟相机获取图像
- **图像裁剪**：根据配置的 `IMAGE_CROP` 函数对图像进行裁剪处理（参考原项目 `FrankaEnv.get_im()`）
- **图像队列**：使用队列机制，丢弃旧帧，只保留最新帧（参考原项目 `VideoCapture`）
- **图像压缩**：JPEG 压缩，减少传输大小
- **多相机支持**：支持多个相机（wrist_1, wrist_2 等）
- **WebSocket 传输**：通过 WebSocket 实时推送图像，降低延迟（相比 HTTP + base64）

**关键设计**：
- **图像裁剪处理**：
  - 在服务器端应用 `IMAGE_CROP` 配置（从环境配置中获取）
  - 裁剪函数格式：`lambda image: image[y1:y2, x1:x2, :]`（例如：`lambda image: image[200:, :, :]`）
  - 裁剪后的图像再进行 JPEG 压缩和传输
  - 参考原项目 `franka_env.py` 中的 `get_im()` 方法
- **WebSocket 连接**：
  - 服务器端：在仿真循环中持续推送最新图像帧
  - 客户端：建立 WebSocket 连接，异步接收图像数据
  - 使用二进制传输（JPEG 压缩后的字节流），避免 base64 编码开销
- **队列机制**：
  - 参考原项目 `VideoCapture` 的设计：丢弃旧帧，只保留最新帧
  - 图像在仿真循环中持续更新（60 Hz）
  - WebSocket 推送时非阻塞获取最新帧
  - 如果没有新图像，跳过本次推送（客户端保留上次接收的图像）

**与原项目对比**：
- 原项目：从 RealSense 硬件读取图像，本地裁剪处理（延迟 < 5ms）
- Isaac Sim：从虚拟相机获取图像，服务器端裁剪，通过 WebSocket 传输（网络，延迟 5-20ms，比 HTTP 更低）

**图像裁剪配置说明**：
- 裁剪配置从环境配置类（`DefaultEnvConfig`）的 `IMAGE_CROP` 属性获取
- `IMAGE_CROP` 是一个字典，键是相机标识符（如 `"wrist_1"`），值是裁剪函数（lambda 函数）
- 裁剪函数接收原始图像（numpy array，H×W×3），返回裁剪后的图像
- 裁剪在服务器端执行，减少传输数据量

**图像裁剪配置示例**（参考原项目 `ram_insertion/config.py`、`egg_flip/config.py`）：
```python
# 在环境配置类中定义
class EnvConfig(DefaultEnvConfig):
    IMAGE_CROP = {
        "wrist_1": lambda image: image[200:, :, :],  # 裁剪掉顶部 200 像素
        "wrist_2": lambda image: image[:, 100:900, :],  # 裁剪左右边缘（保留中间 800 像素宽度）
    }
```

**裁剪处理流程**：
1. 从 Isaac Sim 虚拟相机获取原始图像（RGBA，转换为 RGB）
2. 根据 `IMAGE_CROP[cam_key]` 应用裁剪函数（如果配置了）
3. JPEG 压缩裁剪后的图像
4. 通过 WebSocket 推送压缩后的图像数据

##### 功能5：HTTP 服务接口

**功能描述**：
- **RESTful API**：提供与原项目完全一致的 HTTP 接口
- **路由处理**：处理控制命令和状态查询请求
- **JSON 序列化**：将状态数据序列化为 JSON 格式
- **错误处理**：处理网络错误、超时等异常情况
- **健康检查**：提供健康检查接口，用于监控服务器状态

**关键设计**：
- 所有路由与原项目 `franka_server.py` 保持一致
- 请求/响应格式完全一致
- 支持超时和重试机制

**HTTP 路由**：
- 控制命令：`/pose`, `/close_gripper`, `/open_gripper`, `/move_gripper`, `/clearerr`, `/update_param`, `/jointreset`
- 状态查询：`/getstate`, `/getpos`, `/getvel`, `/getforce`, `/gettorque`, `/getq`, `/getdq`, `/getjacobian`, `/get_gripper`
- 健康检查：`/health`（新增）

**注意**：图像传输使用 WebSocket 协议（见功能4），不再使用 HTTP 路由。

##### 功能6：WebSocket 服务接口

**功能描述**：
- **WebSocket 连接**：提供 WebSocket 服务器，用于实时图像传输
- **图像推送**：在仿真循环中持续推送最新图像帧
- **二进制传输**：使用二进制格式传输 JPEG 压缩后的图像数据
- **多相机支持**：支持多个相机同时推送（每个相机一个 WebSocket 连接，或使用消息标识区分）

**关键设计**：
- **连接管理**：
  - WebSocket 路径：`ws://<server_url>:<port>/images`
  - 支持多个客户端同时连接
  - 自动处理连接断开和重连
- **消息格式**：
  - 消息类型：二进制消息（Binary Message）
  - 消息结构：`<camera_key_length><camera_key><image_data>`
    - `camera_key_length`: 1 字节，相机标识符长度
    - `camera_key`: 字符串，相机标识符（如 "wrist_1"）
    - `image_data`: JPEG 压缩后的图像字节流
- **推送频率**：
  - 与仿真频率同步（60 Hz）
  - 只推送最新帧（丢弃旧帧）
  - 如果客户端连接较慢，自动跳过中间帧

**与原项目对比**：
- 原项目：本地读取图像，无网络传输
- Isaac Sim：WebSocket 实时推送，延迟比 HTTP 更低（5-20ms vs 10-50ms）

#### 1.3 模块内部架构

**IsaacSimServer 类设计**：

```
IsaacSimServer
├── 初始化模块
│   ├── 启动 SimulationApp
│   ├── 创建 World 和场景
│   ├── 添加机器人（Franka）
│   ├── 添加相机（Camera）
│   ├── 初始化状态缓存
│   ├── 初始化图像裁剪配置（IMAGE_CROP）
│   ├── 启动 WebSocket 服务器
│   └── 启动仿真循环线程
│
├── 仿真管理模块
│   ├── _simulation_loop() - 仿真循环（60 Hz）
│   ├── _update_state_fast() - 快速更新状态
│   ├── _update_images_fast() - 快速更新图像（裁剪 + 压缩）
│   └── _setup_controller() - 设置控制器
│
├── 控制接口模块
│   ├── set_pose() - 设置位姿（需要 IK）
│   ├── set_gripper() - 设置夹爪
│   └── _apply_pose_command() - 应用位姿命令
│
├── 状态查询模块
│   ├── get_state() - 获取所有状态（加锁）
│   └── state_cache - 状态缓存（线程安全）
│
├── 图像处理模块
│   ├── _crop_image() - 应用图像裁剪（根据 IMAGE_CROP 配置）
│   ├── _compress_image() - JPEG 压缩
│   └── image_queues - 图像队列（每个相机一个，maxsize=1）
│
├── WebSocket 服务模块
│   ├── _websocket_handler() - WebSocket 连接处理
│   ├── _push_image() - 推送图像到所有连接的客户端
│   └── websocket_clients - WebSocket 客户端列表（线程安全）
│
└── 生命周期管理
    └── close() - 关闭服务器和 WebSocket 服务
```

**Flask App 设计**：

```
Flask App
├── 路由注册
│   ├── 控制命令路由（/pose, /close_gripper, ...）
│   ├── 状态查询路由（/getstate, /getpos, ...）
│   ├── 图像获取路由（/get_images）
│   └── 健康检查路由（/health）
│
├── 请求处理
│   ├── JSON 解析
│   ├── 参数验证
│   └── 错误处理
│
└── 响应生成
    ├── JSON 序列化
    └── 状态码设置
```

#### 1.4 与原项目 franka_server.py 的对比

| 功能 | 原项目（franka_server.py） | Isaac Sim（isaac_sim_server.py） |
|------|-------------------------|--------------------------------|
| **应用管理** | ROS1 节点 + 阻抗控制器 | SimulationApp + 物理引擎 |
| **机器人控制** | ROS1 消息发布 | Isaac Sim API 调用 |
| **状态获取** | ROS1 消息订阅 | Isaac Sim API 查询 |
| **图像获取** | RealSense 硬件 | Isaac Sim 虚拟相机 |
| **HTTP 接口** | Flask 路由 | Flask 路由（完全一致） |
| **线程模型** | 单线程（ROS1 回调） | 多线程（仿真循环 + HTTP 服务） |

**关键差异**：
- 原项目：ROS1 是事件驱动的，通过回调函数处理消息
- Isaac Sim：需要主动轮询和步进，使用独立线程运行仿真循环

### 2. Gym 环境模块功能设计

#### 2.1 模块定位

**IsaacSimFrankaEnv** 是一个 Gym 环境类，通过 HTTP 请求与 Isaac Sim Flask 服务器通信，提供与 `FrankaEnv` 完全相同的接口。

**核心职责**：
1. **环境接口实现**：实现标准的 Gym 环境接口（`reset`, `step`, `observation_space`, `action_space`）
2. **HTTP 通信**：通过 HTTP 请求发送控制命令和查询状态
3. **观察构建**：构建观察字典（状态 + 图像）
4. **奖励计算**：计算任务奖励（二进制奖励）
5. **延迟优化**：优化网络延迟，确保观察状态及时更新

#### 2.2 功能详细描述

##### 功能1：环境接口实现

**功能描述**：
- **reset()**：重置环境到初始状态
- **step()**：执行一步动作，返回观察、奖励、完成标志
- **observation_space**：定义观察空间（状态 + 图像）
- **action_space**：定义动作空间（7 维：位置增量 + 旋转增量 + 夹爪）

**关键设计**：
- 接口与原项目 `FrankaEnv` 完全一致
- 支持随机重置（可选）
- 支持安全边界框限制

##### 功能2：HTTP 通信

**功能描述**：
- **连接管理**：使用 HTTP 连接池，复用连接，减少延迟
- **请求发送**：发送控制命令（`/pose`, `/close_gripper` 等）
- **状态查询**：查询机器人状态（`/getstate`）
- **图像获取**：获取相机图像（`/get_images`）
- **错误处理**：处理网络错误、超时等异常情况
- **重试机制**：自动重试失败的请求

**关键设计**：
- 使用 `requests.Session` 和连接池
- 设置合理的超时时间（状态查询：100ms，图像获取：200ms）
- 实现重试策略（最多 3 次，指数退避）

**与原项目对比**：
- 原项目：使用 `requests.post()` 直接发送请求
- Isaac Sim：使用连接池和会话，优化性能

##### 功能3：观察构建

**功能描述**：
- **状态观察**：从 HTTP 响应中提取状态信息（位姿、速度、力/力矩等）
- **图像观察**：从 HTTP 响应中解码图像（base64 → JPEG → numpy array）
- **图像处理**：应用图像裁剪、调整大小等处理
- **观察字典**：构建标准的观察字典格式

**关键设计**：
- 状态和图像可以并行获取（减少总延迟）
- 图像需要解码和处理（base64 → JPEG → numpy）
- 确保图像格式正确（uint8, RGB, 128x128）

##### 功能4：奖励计算

**功能描述**：
- **位姿比较**：比较当前位姿和目标位姿
- **阈值判断**：判断是否在奖励阈值内
- **二进制奖励**：返回 0 或 1（成功或失败）

**关键设计**：
- 与原项目 `FrankaEnv.compute_reward()` 完全一致
- 支持位置和姿态的阈值判断

##### 功能5：延迟优化

**功能描述**：
- **连接池**：复用 HTTP 连接，减少连接建立时间
- **并行请求**：状态和图像并行获取（可选优化）
- **超时控制**：设置合理的超时时间，避免长时间等待
- **错误恢复**：网络错误时使用缓存状态（如果有）

**关键设计**：
- 目标延迟：总观察延迟 < 50ms
- 状态查询延迟：< 20ms（HTTP）
- 图像获取延迟：< 20ms（WebSocket，比 HTTP 更低）

#### 2.3 模块内部架构

**IsaacSimFrankaEnv 类设计**：

```
IsaacSimFrankaEnv (gym.Env)
├── 初始化模块
│   ├── 配置加载（SERVER_URL, ACTION_SCALE, 等）
│   ├── 创建 HTTP 会话（连接池）
│   ├── 定义动作/观察空间
│   └── 初始化状态变量
│
├── 环境接口模块
│   ├── reset() - 重置环境
│   ├── step() - 执行一步动作
│   └── close() - 关闭环境
│
├── 通信模块
│   ├── _send_pos_command() - 发送位姿命令（HTTP）
│   ├── _send_gripper_command() - 发送夹爪命令（HTTP）
│   ├── _update_currpos() - 更新状态（HTTP 请求）
│   ├── _connect_websocket() - 建立 WebSocket 连接
│   ├── _receive_images_loop() - WebSocket 接收循环（独立线程）
│   └── _get_images() - 从缓存获取最新图像
│
├── 观察构建模块
│   ├── _get_obs() - 构建观察字典
│   └── _get_observation_space() - 定义观察空间
│
├── 奖励计算模块
│   └── compute_reward() - 计算奖励
│
└── 工具模块
    ├── clip_safety_box() - 安全边界框限制
    ├── interpolate_move() - 线性插值移动
    └── _get_reset_pose() - 获取重置位姿
```

#### 2.4 与原项目 FrankaEnv 的对比

| 功能 | 原项目（FrankaEnv） | Isaac Sim（IsaacSimFrankaEnv） |
|------|-------------------|------------------------------|
| **环境接口** | Gym 标准接口 | Gym 标准接口（完全一致） |
| **通信方式** | HTTP 请求（requests） | HTTP 请求（状态/控制）+ WebSocket（图像） |
| **服务器** | franka_server.py (ROS1) | isaac_sim_server.py (Isaac Sim + WebSocket) |
| **状态获取** | HTTP POST /getstate | HTTP POST /getstate（完全一致） |
| **图像获取** | 本地读取（RealSense） | WebSocket 实时推送（已裁剪、已压缩） |
| **图像裁剪** | 客户端裁剪（`IMAGE_CROP`） | 服务器端裁剪（`IMAGE_CROP`，减少传输量） |
| **延迟** | 本地读取（< 5ms） | WebSocket 传输（5-20ms，比 HTTP 更低） |

**关键差异**：
- 原项目：图像从本地硬件读取，客户端裁剪，延迟极低
- Isaac Sim：图像通过 WebSocket 传输，服务器端裁剪，延迟较低（比 HTTP 更低）

### 3. 接口设计原则

#### 3.1 接口一致性原则

**原则**：所有 HTTP 接口与原项目 `franka_server.py` 保持完全一致

**实现**：
- 路由路径相同（`/pose`, `/getstate`, 等）
- 请求格式相同（JSON 格式）
- 响应格式相同（JSON 格式）
- 错误处理相同（返回状态码和错误信息）

**好处**：
- 训练代码无需修改
- 可以轻松切换真机和仿真环境
- 降低开发和维护成本

#### 3.2 延迟优化原则

**原则**：确保观察状态延迟足够低（< 50ms），使得控制命令基于最新状态

**实现**：
- 状态缓存：持续更新，快速查询
- 图像队列：丢弃旧帧，只保留最新帧
- 连接池：复用连接，减少连接建立时间
- 并行请求：状态和图像并行获取（可选）

#### 3.3 线程安全原则

**原则**：多线程环境下确保数据一致性

**实现**：
- 状态缓存：更新时不加锁（快速），查询时加锁（一致性）
- 图像队列：使用线程安全的 `queue.Queue`
- 命令队列：使用线程安全的队列

#### 3.4 错误处理原则

**原则**：网络错误时优雅降级，不中断训练

**实现**：
- 自动重试：网络错误自动重试（最多 3 次）
- 超时处理：设置合理的超时时间
- 缓存机制：网络错误时使用缓存状态（如果有）
- 日志记录：记录错误信息，便于调试

---

## Flask 服务器接口详细设计

### 1. IsaacSimServer 类详细设计

#### 1.1 类结构设计

**类名**：`IsaacSimServer`

**职责**：管理 Isaac Sim 仿真环境，提供状态查询和控制接口

**关键属性**：
- `simulation_app`: SimulationApp 实例
- `world`: World 实例（物理世界）
- `franka`: Franka 实例（机器人）
- `cameras`: Dict[str, Camera]（相机字典）
- `state_cache`: Dict（状态缓存，线程安全）
- `image_queues`: Dict[str, Queue]（图像队列，每个相机一个）
- `state_lock`: Lock（状态锁）
- `running`: bool（运行标志）

**关键方法**：
- `__init__()`: 初始化 Isaac Sim 和场景
- `_simulation_loop()`: 仿真循环（独立线程）
- `_update_state_fast()`: 快速更新状态（不加锁）
- `_update_images_fast()`: 快速更新图像（丢弃旧帧）
- `set_pose()`: 设置机器人位姿（需要 IK）
- `get_state()`: 获取所有状态（加锁）
- `get_images()`: 获取最新图像（非阻塞）
- `set_gripper()`: 设置夹爪位置
- `close()`: 关闭服务器

#### 1.2 状态管理设计

**状态缓存机制**：
- **更新频率**：60 Hz（每个物理步进更新一次）
- **更新方式**：不加锁，直接更新（快速）
- **查询方式**：加锁，复制状态快照（一致性）
- **状态字段**：pose, vel, force, torque, q, dq, jacobian, gripper_pos

**线程安全设计**：
- 仿真循环线程：快速更新状态（不加锁）
- HTTP 请求线程：查询状态（加锁，确保一致性）

#### 1.3 图像管理设计

**图像队列机制**：
- **队列大小**：maxsize=1（只保留最新帧）
- **更新频率**：60 Hz（每个物理步进更新一次）
- **更新策略**：丢弃旧帧，只保留最新帧
- **查询方式**：非阻塞获取（`get_nowait()`）

**参考原项目**：
- 原项目 `VideoCapture` 使用相同的机制：丢弃旧帧，只保留最新帧

#### 1.4 控制命令设计

**命令执行流程**：
1. 接收 HTTP 请求（位姿命令）
2. 执行 IK 求解（将位姿转换为关节目标）
3. 设置关节目标（`franka.set_joint_position_targets()`）
4. 物理引擎自动执行（在下一个物理步进）

**IK 求解**：
- 需要实现 IK 求解器（可以使用 Isaac Sim 的控制器或自定义实现）
- 支持实时 IK 求解（延迟 < 10ms）

### 2. Flask HTTP 路由详细设计

#### 2.1 控制命令路由

**路由设计原则**：
- 所有路由与原项目 `franka_server.py` 保持一致
- 请求/响应格式完全一致
- 支持超时和错误处理

**路由列表**：
- `/pose`: 发送位姿命令
- `/close_gripper`: 关闭夹爪
- `/open_gripper`: 打开夹爪
- `/move_gripper`: 移动夹爪
- `/clearerr`: 清除错误
- `/update_param`: 更新参数
- `/jointreset`: 关节复位

#### 2.2 状态查询路由

**路由设计原则**：
- 提供快速的状态查询接口
- 支持单独查询各项状态
- 最常用的是 `/getstate`（获取所有状态）

**路由列表**：
- `/getstate`: 获取所有状态（最常用）
- `/getpos`: 获取位姿
- `/getvel`: 获取速度
- `/getforce`: 获取力
- `/gettorque`: 获取力矩
- `/getq`: 获取关节位置
- `/getdq`: 获取关节速度
- `/getjacobian`: 获取雅可比
- `/get_gripper`: 获取夹爪位置

#### 2.3 图像获取路由（新增）

**路由设计**：
- `/get_images`: 获取所有相机的最新图像
- 响应格式：JSON，包含 base64 编码的 JPEG 图像
- 支持多相机（wrist_1, wrist_2 等）

**图像处理流程**：
1. 从图像队列获取最新帧（非阻塞）
2. JPEG 压缩（质量 85，减少传输大小）
3. Base64 编码
4. 返回 JSON 响应

### 3. Gym 环境接口详细设计

#### 3.1 IsaacSimFrankaEnv 类详细设计

**类名**：`IsaacSimFrankaEnv`

**继承**：`gym.Env`

**职责**：通过 HTTP 请求与 Isaac Sim Flask 服务器通信，提供标准的 Gym 环境接口

**关键属性**：
- `url`: str（Flask 服务器 URL）
- `session`: requests.Session（HTTP 会话，连接池）
- `ws_url`: str（WebSocket 服务器 URL，如 `ws://<host>:<port>/images`）
- `ws_client`: WebSocket 客户端（用于接收图像）
- `image_cache`: Dict[str, np.ndarray]（图像缓存，存储最新接收的图像）
- `config`: DefaultEnvConfig（环境配置，包含 `IMAGE_CROP`）
- `action_space`: gym.spaces.Box（动作空间）
- `observation_space`: gym.spaces.Dict（观察空间）
- `currpos`, `currvel`, 等（当前状态）

**关键方法**：
- `__init__()`: 初始化环境，创建 HTTP 会话和 WebSocket 连接
- `reset()`: 重置环境
- `step()`: 执行一步动作
- `_send_pos_command()`: 发送位姿命令
- `_update_currpos()`: 更新状态（HTTP 请求）
- `_connect_websocket()`: 建立 WebSocket 连接
- `_receive_images_loop()`: WebSocket 接收循环（独立线程）
- `_get_images()`: 从缓存获取最新图像
- `_get_obs()`: 构建观察字典
- `compute_reward()`: 计算奖励
- `close()`: 关闭 HTTP 会话和 WebSocket 连接

#### 3.2 HTTP 通信设计

**连接池设计**：
- 使用 `requests.Session` 和 `HTTPAdapter`
- 连接池大小：1（单连接复用）
- 支持自动重试（最多 3 次）

**请求设计**：
- 超时设置：状态查询 100ms
- 错误处理：自动重试，优雅降级
- 日志记录：记录错误信息

#### 3.3 WebSocket 通信设计

**连接设计**：
- 使用 `websocket-client` 或 `websockets` 库
- WebSocket URL：`ws://<server_url>:<port>/images`
- 连接保持：长连接，持续接收图像数据
- 自动重连：连接断开时自动重连（指数退避）

**接收设计**：
- **异步接收**：使用异步或线程方式持续接收图像
- **消息解析**：解析二进制消息，提取相机标识符和图像数据
- **图像解码**：将 JPEG 字节流解码为 numpy 数组
- **图像处理**：应用图像处理（如果需要进一步处理）
- **缓存机制**：缓存最新接收的图像，供 `_get_obs()` 使用

**性能优化**：
- 目标延迟：图像接收延迟 < 20ms（比 HTTP 更低）
- 帧率控制：如果接收速度跟不上，自动丢弃中间帧
- 错误处理：网络错误时使用缓存图像，不中断训练

#### 3.4 观察构建设计

**观察字典格式**：
```python
{
    "state": {
        "tcp_pose": np.ndarray[7],      # xyz + quat
        "tcp_vel": np.ndarray[6],
        "gripper_pose": np.ndarray[1],
        "tcp_force": np.ndarray[3],
        "tcp_torque": np.ndarray[3],
    },
    "images": {
        "wrist_1": np.ndarray[128, 128, 3],  # uint8, RGB
        "wrist_2": np.ndarray[128, 128, 3],
    },
}
```

**构建流程**：
1. 并行获取状态和图像（可选优化）
   - 状态：HTTP 请求 `/getstate`
   - 图像：从 WebSocket 接收缓存中获取最新帧
2. 图像处理：
   - 图像已在服务器端裁剪（根据 `IMAGE_CROP` 配置）
   - 客户端只需解码 JPEG 字节流为 numpy 数组
   - 如果需要，可以进一步调整大小（通常服务器端已处理）
3. 构建观察字典

---

## 代码实现计划

### 说明

**代码实现将在功能确认后提供**。当前文档重点描述功能设计和接口规范，确保设计正确后再进行代码实现。

### 实现计划

1. **Isaac Sim Flask Server 实现**
   - 实现 `IsaacSimServer` 类
   - 实现 Flask HTTP 路由
   - 实现状态缓存和图像队列机制
   - 实现 IK 求解器（或集成现有控制器）

2. **Gym 环境实现**
   - 实现 `IsaacSimFrankaEnv` 类
   - 实现 HTTP 通信（连接池、重试机制）
   - 实现观察构建（状态 + 图像）
   - 实现延迟优化（并行请求等）

3. **配置修改**
   - 修改实验配置文件，添加 Isaac Sim 环境选项
   - 添加 `SERVER_URL` 配置

---

## 接口规范参考

### 1. Flask HTTP 路由规范

#### 1.1 控制命令路由规范

| 路由 | 方法 | 请求格式 | 响应格式 | 功能说明 |
|------|------|---------|---------|---------|
| `/pose` | POST | `{"arr": [x, y, z, qx, qy, qz, qw]}` | `"Moved"` | 发送末端执行器位姿命令 |
| `/close_gripper` | POST | - | `"Closed"` | 关闭夹爪 |
| `/open_gripper` | POST | - | `"Opened"` | 打开夹爪 |
| `/move_gripper` | POST | `{"gripper_pos": float}` | `"Moved Gripper"` | 移动夹爪到指定位置 |
| `/clearerr` | POST | - | `"Clear"` | 清除错误 |
| `/update_param` | POST | `{"param": value}` | `"Updated"` | 更新参数 |
| `/jointreset` | POST | - | `"Reset Joint"` | 执行关节复位 |

#### 1.2 状态查询路由规范

| 路由 | 方法 | 请求格式 | 响应格式 | 功能说明 |
|------|------|---------|---------|---------|
| `/getstate` | POST | - | `{"pose": [...], "vel": [...], "force": [...], "torque": [...], "q": [...], "dq": [...], "jacobian": [...], "gripper_pos": ...}` | 获取所有机器人状态（最常用） |
| `/getpos` | POST | - | `{"pose": [...]}` | 获取末端执行器位姿 |
| `/getvel` | POST | - | `{"vel": [...]}` | 获取末端执行器速度 |
| `/getforce` | POST | - | `{"force": [...]}` | 获取末端执行器力 |
| `/gettorque` | POST | - | `{"torque": [...]}` | 获取末端执行器力矩 |
| `/getq` | POST | - | `{"q": [...]}` | 获取关节位置 |
| `/getdq` | POST | - | `{"dq": [...]}` | 获取关节速度 |
| `/getjacobian` | POST | - | `{"jacobian": [...]}` | 获取雅可比矩阵 |
| `/get_gripper` | POST | - | `{"gripper": float}` | 获取夹爪位置 |

#### 1.3 WebSocket 图像传输规范（新增）

| 协议 | 路径 | 连接方式 | 消息格式 | 功能说明 |
|------|------|---------|---------|---------|
| **WebSocket** | `/images` | 长连接 | 二进制消息：`<camera_key_length><camera_key><jpeg_data>` | 实时推送所有相机的最新图像（JPEG 压缩，已裁剪） |

**WebSocket 消息格式详解**：
- **消息类型**：二进制消息（Binary Message）
- **消息结构**：
  ```
  [1 byte: camera_key_length][N bytes: camera_key][M bytes: JPEG image data]
  ```
- **示例**：
  - 相机标识符：`"wrist_1"` (7 字节)
  - 消息：`[0x07][0x77, 0x72, 0x69, 0x73, 0x74, 0x5f, 0x31][JPEG bytes...]`
- **推送频率**：60 Hz（与仿真频率同步）
- **图像处理**：
  - 服务器端已应用 `IMAGE_CROP` 裁剪
  - 服务器端已进行 JPEG 压缩
  - 客户端只需解码 JPEG 字节流

#### 1.4 健康检查路由规范

| 路由 | 方法 | 请求格式 | 响应格式 | 功能说明 |
|------|------|---------|---------|---------|
| `/health` | GET | - | `{"status": "healthy", "simulation_running": bool}` | 健康检查 |

### 2. Gym 环境接口规范

#### 2.1 标准接口

所有环境必须实现以下接口：

- `reset(**kwargs) -> Tuple[Dict, Dict]`: 重置环境
- `step(action: np.ndarray) -> Tuple[Dict, float, bool, bool, Dict]`: 执行一步动作
- `observation_space: gym.Space`: 观察空间定义
- `action_space: gym.Space`: 动作空间定义

#### 2.2 观察格式规范

**观察字典结构**：
```python
{
    "state": {
        "tcp_pose": np.ndarray[7],      # xyz + quat
        "tcp_vel": np.ndarray[6],
        "gripper_pose": np.ndarray[1],
        "tcp_force": np.ndarray[3],
        "tcp_torque": np.ndarray[3],
    },
    "images": {
        "wrist_1": np.ndarray[128, 128, 3],  # uint8, RGB
        "wrist_2": np.ndarray[128, 128, 3],
    },
}
```

#### 2.3 动作格式规范

**动作数组结构**：
```python
action: np.ndarray[7], dtype=np.float32
# action[0:3]: xyz 位置增量 (相对动作，单位：米)
# action[3:6]: 旋转增量 (rotvec，单位：弧度)
# action[6]: 夹爪动作 (-1: 关闭, 1: 打开)
```

---

## 待确认事项

在开始代码实现前，需要确认以下事项：

1. **IK 求解器选择**
   - 使用 Isaac Sim 的 `RMPFlowController`？
   - 使用 Isaac Sim 的 `InverseKinematicsSolver`？
   - 还是实现自定义 IK 求解器？

2. **图像传输方式**
   - ✅ 已确认：使用 WebSocket 实时传输（降低延迟）
   - 图像在服务器端裁剪和压缩后传输

3. **状态更新频率**
   - 状态缓存更新频率：60 Hz（每个物理步进）？
   - 还是与控制频率同步（10 Hz）？

4. **错误处理策略**
   - 网络错误时使用缓存状态？
   - 还是抛出异常？

5. **性能目标**
   - 状态查询延迟目标：< 20ms？
   - 图像获取延迟目标：< 30ms？
   - 总观察延迟目标：< 50ms？

**请在确认以上事项后，再进行代码实现。**

---

## 数据采集接口

### 1. 演示数据采集接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- 只需在配置中选择使用 `IsaacSimFrankaEnv` 环境
- 数据采集流程完全相同

**使用方式**：
```python
# examples/record_demos.py
# 只需修改环境创建部分
env = config.get_environment(
    fake_env=True,  # 使用仿真环境
    save_video=False,
    classifier=True,
)
# 其他代码完全不变
```

### 2. 分类器数据采集接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- 只需在配置中选择使用 `IsaacSimFrankaEnv` 环境

---

## 训练接口

### 1. Actor 进程接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- 只需在配置中选择使用 `IsaacSimFrankaEnv` 环境
- Actor 循环代码完全不变

### 2. Learner 进程接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- 数据管理机制完全不变
- Learner 循环代码完全不变

---

## 数据同步接口

### 1. DataStore 接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- `QueuedDataStore`（Actor 端）和 `ReplayBufferDataStore`（Learner 端）完全复用

### 2. TrainerClient/Server 接口

**接口说明**：
- 接口与原项目完全一致，无需修改
- 网络通信机制完全不变

---

## 延迟优化接口

### 1. HTTP 连接池接口

**功能说明**：
- 使用 `requests.Session` 和 `HTTPAdapter` 创建连接池
- 复用 HTTP 连接，减少连接建立时间
- 支持自动重试机制

### 2. WebSocket 图像接收接口

**功能说明**：
- 使用 WebSocket 长连接实时接收图像
- 在独立线程中运行接收循环
- 图像数据缓存到内存，供 `_get_obs()` 快速访问
- 支持自动重连机制

### 3. 并行请求接口

**功能说明**：
- 状态查询（HTTP）和图像获取（WebSocket 缓存）可以并行执行
- 使用 `concurrent.futures.ThreadPoolExecutor` 实现（可选优化）
- 减少总观察延迟

### 4. 状态缓存接口（Flask 服务器端）

**功能说明**：
- 状态在仿真循环中持续更新（不加锁，快速）
- 查询时加锁获取状态快照（确保一致性）
- 参考原项目的状态更新机制

### 5. 图像处理与推送接口（Flask 服务器端）

**功能说明**：
- **图像裁剪**：在仿真循环中应用 `IMAGE_CROP` 配置进行裁剪
- **图像压缩**：JPEG 压缩，减少传输大小
- **图像队列**：使用队列机制，丢弃旧帧，只保留最新帧
- **WebSocket 推送**：在仿真循环中持续推送最新图像帧（60 Hz）
- 参考原项目 `VideoCapture` 和 `FrankaEnv.get_im()` 的设计

---

## 实现示例

### 1. 完整使用示例

**使用流程**：
1. 启动 Flask 服务器（主机1）
2. 配置环境 URL（主机2）
3. 创建环境（主机2）
4. 启动训练（主机2）

**关键配置**：
- Flask 服务器 URL：`http://<主机1的IP>:5001/`
- 环境类型：`fake_env=True`（使用仿真环境）

### 2. 延迟测试示例

**测试内容**：
- 状态更新延迟测试
- 图像获取延迟测试
- 总观察延迟测试

**性能目标**：
- 状态查询延迟：< 20ms（HTTP）
- 图像获取延迟：< 20ms（WebSocket，比 HTTP 更低）
- 总观察延迟：< 50ms

---

## 接口兼容性总结

### 与原项目对比

| 接口 | 原项目（真机） | 方案B（仿真） | 兼容性 |
|------|---------------|---------------|--------|
| **Gym 环境接口** | `FrankaEnv` | `IsaacSimFrankaEnv` | ✅ 完全兼容 |
| **HTTP 路由** | `franka_server.py` | `isaac_sim_server.py` | ✅ 完全兼容（控制命令和状态查询） |
| **图像传输** | 本地读取（RealSense） | WebSocket 实时推送 | ✅ 功能兼容（延迟更低） |
| **图像裁剪** | 客户端裁剪 | 服务器端裁剪 | ✅ 功能兼容（处理位置不同） |
| **数据采集接口** | `record_demos.py` | 无需修改 | ✅ 完全兼容 |
| **训练接口** | `train_rlpd.py` | 无需修改 | ✅ 完全兼容 |
| **数据同步接口** | `DataStore` | 无需修改 | ✅ 完全兼容 |

### 关键设计原则

1. **接口一致性**：所有接口与原项目保持完全一致
2. **延迟优化**：确保观察状态延迟 < 50ms
3. **错误处理**：网络错误自动重试，优雅降级
4. **线程安全**：状态缓存使用锁保护
5. **最新帧机制**：图像队列丢弃旧帧，只保留最新帧

---

## 总结

本文档详细设计了基于 Flask 服务器中转的 Isaac Sim 接口方案，关键特点：

1. **架构一致性**：与原项目保持相同的 HTTP 接口
2. **延迟优化**：通过连接池、并行请求、状态缓存等机制降低延迟
3. **代码复用**：训练代码无需修改，只需替换环境类
4. **双机部署**：支持仿真环境和训练分离部署
5. **错误处理**：完善的错误处理和重试机制

所有接口设计都遵循"最小修改原则"，确保与原项目的兼容性和代码复用性。

**代码实现将在功能确认后提供。**

---

# Isaac Sim 环境实现方案 V2（方案B：Flask 服务器中转）

## 方案概述

**方案B：使用 Flask 服务器作为消息中转节点**

- ✅ 不依赖 IsaacLab 的复杂环境构建
- ✅ 不使用 IsaacLab 的内部类
- ✅ 直接使用 `omni.isaac.kit.SimulationApp` 启动 Isaac Sim
- ✅ 使用 Isaac Sim 原生 API（`omni.isaac.core` 等）
- ✅ **使用 Flask 服务器作为消息中转，保持与原项目架构一致**
- ✅ **支持仿真环境和策略分离部署（两台主机）**

## 项目整体架构

### 1. 系统功能架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        HIL-SERL 完整系统架构                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          仿真环境模块 (主机1)                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Isaac Sim Flask Server                          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                     │   │
│  │  ┌──────────────┐         ┌──────────────┐         ┌──────────┐  │   │
│  │  │  Flask App   │         │ IsaacSimServer│         │ Isaac Sim │  │   │
│  │  │              │         │              │         │ Simulation│  │   │
│  │  │ - HTTP路由   │◄───────►│ - 仿真管理   │◄───────►│           │  │   │
│  │  │ - 请求处理   │         │ - 状态更新   │         │ - 物理引擎│  │   │
│  │  │ - JSON响应   │         │ - 机器人控制 │         │ - 渲染引擎│  │   │
│  │  └──────┬───────┘         └──────────────┘         └──────────┘  │   │
│  │         │                                                          │   │
│  │         │ HTTP POST/GET                                            │   │
│  │         │ (控制命令/状态查询)                                       │   │
│  └─────────┼──────────────────────────────────────────────────────────┘   │
│            │                                                                 │
└────────────┼───────────────────────────────────────────────────────────────┘
             │
             │ 网络 (HTTP)
             │
┌────────────┼───────────────────────────────────────────────────────────────┐
│            │                    RL 训练模块 (主机2)                          │
├────────────┼───────────────────────────────────────────────────────────────┤
│            │                                                                 │
│  ┌─────────▼──────────┐         ┌──────────────────┐                      │
│  │   Gym Environment │         │   Actor 进程      │                      │
│  │                    │         │                   │                      │
│  │ IsaacSimFrankaEnv  │         │ - 环境交互        │                      │
│  │                    │         │ - 数据收集        │                      │
│  │ - step()           │◄───────►│ - 策略执行        │                      │
│  │ - reset()          │         │ - 干预记录        │                      │
│  │ - _get_obs()       │         │                   │                      │
│  └─────────┬──────────┘         └─────────┬────────┘                      │
│            │                                │                                │
│            │                                │                                │
│  ┌─────────▼────────────────────────────────▼──────────┐                  │
│  │              TrainerClient                             │                  │
│  │              (agentlace)                              │                  │
│  │  - 数据发送到 Learner                                 │                  │
│  │  - 接收参数更新                                       │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
│                          │ 网络通信 (TCP/IP)                                │
│                          │                                                  │
│  ┌───────────────────────▼───────────────────────────────┐                  │
│  │              TrainerServer                             │                  │
│  │              (agentlace)                               │                  │
│  │  - 接收 Actor 数据                                     │                  │
│  │  - 发布参数更新                                       │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
│  ┌───────────────────────▼───────────────────────────────┐                  │
│  │              Learner 进程                              │                  │
│  │                                                         │                  │
│  │  - 模型训练 (SAC Agent)                                │                  │
│  │  - 参数更新                                            │                  │
│  │  - 检查点保存                                          │                  │
│  └───────────────────────┬───────────────────────────────┘                  │
│                          │                                                  │
└──────────────────────────┼──────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────────────────────┐
│                          数据存储模块                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────┐         ┌──────────────────┐         ┌──────────┐   │
│  │ QueuedDataStore  │         │ ReplayBuffer     │         │ 磁盘存储  │   │
│  │  (Actor 端)      │         │ DataStore        │         │          │   │
│  │                  │         │ (Learner 端)     │         │ - buffer/│   │
│  │ - 在线经验队列    │────────►│                  │◄────────│ - demo_  │   │
│  │ - 干预数据队列    │  网络   │ - 在线经验缓冲区  │  持久化  │   buffer/│   │
│  │                  │         │ - 演示数据缓冲区  │         │          │   │
│  └──────────────────┘         └──────────────────┘         └──────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2. 模块间交互流程

#### 2.1 控制流程（Gym Env → Flask → Isaac Sim）

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  Actor 进程  │      │  Gym Env     │      │ Flask Server  │      │ Isaac Sim    │
│              │      │              │      │               │      │              │
│ agent.sample │      │ env.step()   │      │ /pose         │      │ Simulation   │
│   _actions() │─────►│              │─────►│               │─────►│              │
│              │      │ _send_pos_   │      │ set_pose()    │      │ set_joint_   │
│              │      │  command()   │      │               │      │  targets()   │
└──────────────┘      └──────────────┘      └──────────────┘      └──────────────┘
```

#### 2.2 状态查询流程（Isaac Sim → Flask → Gym Env）

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│ Isaac Sim    │      │ Flask Server  │      │  Gym Env     │      │  Actor 进程  │
│              │      │               │      │              │      │              │
│ Simulation   │      │ /getstate     │      │ _update_      │      │ _get_obs()   │
│              │─────►│               │─────►│  currpos()    │─────►│              │
│ get_state()  │      │ get_state()   │      │              │      │              │
└──────────────┘      └──────────────┘      └──────────────┘      └──────────────┘
```

#### 2.3 数据收集流程（Actor → Learner）

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  Gym Env     │      │ QueuedData   │      │ TrainerClient│      │ TrainerServer│
│              │      │ Store         │      │              │      │              │
│ env.step()   │─────►│              │─────►│              │─────►│              │
│              │      │ insert()     │      │ send_data()  │      │ receive_data │
│ transition   │      │              │      │              │      │              │
└──────────────┘      └──────────────┘      └──────────────┘      └──────┬───────┘
                                                                           │
                                                                           ▼
                                                              ┌──────────────────────┐
                                                              │ ReplayBufferDataStore│
                                                              │                      │
                                                              │ insert()             │
                                                              └──────────────────────┘
```

#### 2.4 参数更新流程（Learner → Actor）

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  Learner     │      │ TrainerServer│      │ TrainerClient│      │  Actor 进程  │
│              │      │              │      │              │      │              │
│ agent.update │─────►│ publish_     │─────►│ recv_network_ │─────►│ update agent │
│   ()         │      │  network()   │      │  callback()   │      │   params     │
└──────────────┘      └──────────────┘      └──────────────┘      └──────────────┘
```

### 3. 模块内部架构设计

#### 3.1 Isaac Sim Flask Server 模块

```
┌─────────────────────────────────────────────────────────────────┐
│              IsaacSimServer 类架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              IsaacSimServer                             │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  - simulation_app: SimulationApp                        │  │
│  │  - world: World                                          │  │
│  │  - franka: Franka                                        │  │
│  │  - cameras: Dict[str, Camera]                           │  │
│  │  - controller: IKController (待实现)                      │  │
│  │                                                          │  │
│  │  方法:                                                   │  │
│  │  - __init__()                                            │  │
│  │  - _setup_controller()                                   │  │
│  │  - _simulation_loop() [线程]                             │  │
│  │  - _update_state()                                       │  │
│  │  - set_pose()                                            │  │
│  │  - get_state()                                            │  │
│  │  - set_gripper()                                         │  │
│  │  - close()                                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              Flask App                                   │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  路由:                                                   │  │
│  │  - /pose → pose() → isaac_sim_server.set_pose()         │  │
│  │  - /getstate → get_state() → isaac_sim_server.get_state()│ │
│  │  - /getpos → get_pos()                                  │  │
│  │  - /getvel → get_vel()                                  │  │
│  │  - /getforce → get_force()                              │  │
│  │  - /gettorque → get_torque()                            │  │
│  │  - /getq → get_q()                                      │  │
│  │  - /getdq → get_dq()                                    │  │
│  │  - /getjacobian → get_jacobian()                        │  │
│  │  - /get_gripper → get_gripper()                         │  │
│  │  - /close_gripper → close_gripper()                     │  │
│  │  - /open_gripper → open_gripper()                      │  │
│  │  - /move_gripper → move_gripper()                      │  │
│  │  - /clearerr → clear()                                  │  │
│  │  - /update_param → update_param()                      │  │
│  │  - /jointreset → joint_reset()                         │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2 Gym Environment 模块

```
┌─────────────────────────────────────────────────────────────────┐
│              IsaacSimFrankaEnv 类架构                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              IsaacSimFrankaEnv (gym.Env)                 │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  属性:                                                   │  │
│  │  - url: str (Flask 服务器 URL)                           │  │
│  │  - config: DefaultEnvConfig                              │  │
│  │  - action_space: gym.spaces.Box                           │  │
│  │  - observation_space: gym.spaces.Dict                     │  │
│  │  - currpos, currvel, currforce, currtorque               │  │
│  │  - curr_gripper_pos                                       │  │
│  │                                                          │  │
│  │  方法:                                                   │  │
│  │  - __init__()                                            │  │
│  │  - step() → obs, reward, done, truncated, info           │  │
│  │  - reset() → obs, info                                   │  │
│  │  - _send_pos_command() → requests.post(url + "pose")    │  │
│  │  - _send_gripper_command() → requests.post(...)          │  │
│  │  - _update_currpos() → requests.post(url + "getstate")   │  │
│  │  - _get_images() → 从 Flask 获取图像                     │  │
│  │  - _get_obs() → Dict[images, state]                      │  │
│  │  - compute_reward() → float                              │  │
│  │  - clip_safety_box() → np.ndarray                        │  │
│  │  - interpolate_move() → None                             │  │
│  │  - close() → None                                        │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.3 RL 训练模块（Actor-Learner 架构）

```
┌─────────────────────────────────────────────────────────────────┐
│              Actor 进程架构                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              actor() 函数                                  │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  1. 初始化:                                              │  │
│  │     - env = IsaacSimFrankaEnv(config)                    │  │
│  │     - agent = SACAgent(...)                              │  │
│  │     - data_store = QueuedDataStore(50000)                │  │
│  │     - intvn_data_store = QueuedDataStore(50000)          │  │
│  │     - client = TrainerClient(...)                         │  │
│  │                                                          │  │
│  │  2. 训练循环:                                            │  │
│  │     for step in range(max_steps):                        │  │
│  │       - actions = agent.sample_actions(obs)              │  │
│  │       - next_obs, reward, done, info = env.step(actions)│  │
│  │       - if intervention:                                │  │
│  │           actions = info["intervene_action"]             │  │
│  │       - transition = {...}                               │  │
│  │       - data_store.insert(transition)                    │  │
│  │       - if intervention:                                │  │
│  │           intvn_data_store.insert(transition)           │  │
│  │       - client.update()  # 发送数据到 Learner             │  │
│  │                                                          │  │
│  │  3. 参数更新回调:                                        │  │
│  │     def update_params(params):                           │  │
│  │         agent = agent.replace(state=agent.state.replace( │  │
│  │             params=params))                               │  │
│  │     client.recv_network_callback(update_params)          │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│              Learner 进程架构                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              learner() 函数                              │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  1. 初始化:                                              │  │
│  │     - agent = SACAgent(...)                             │  │
│  │     - replay_buffer = MemoryEfficientReplayBufferDataStore│ │
│  │     - demo_buffer = MemoryEfficientReplayBufferDataStore │  │
│  │     - server = TrainerServer(...)                       │  │
│  │     - server.register_data_store("actor_env", replay_buffer)│ │
│  │     - server.register_data_store("actor_env_intvn", demo_buffer)│ │
│  │                                                          │  │
│  │  2. 数据加载:                                           │  │
│  │     - 从磁盘恢复 replay_buffer                          │  │
│  │     - 从磁盘恢复 demo_buffer                            │  │
│  │     - 加载预收集的演示数据                               │  │
│  │                                                          │  │
│  │  3. 训练循环:                                           │  │
│  │     for step in range(max_steps):                       │  │
│  │       - batch = replay_buffer.sample(batch_size // 2)   │  │
│  │       - demo_batch = demo_buffer.sample(batch_size // 2)│  │
│  │       - batch = concat_batches(batch, demo_batch)       │  │
│  │       - agent, info = agent.update(batch)               │  │
│  │       - if step % steps_per_update == 0:                │  │
│  │           server.publish_network(agent.state.params)    │  │
│  │                                                          │  │
│  │  4. 检查点保存:                                         │  │
│  │     - checkpoints.save_checkpoint(...)                  │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.4 数据存储模块架构

```
┌─────────────────────────────────────────────────────────────────┐
│              数据存储类架构                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              QueuedDataStore (Actor 端)                  │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  - queue: queue.Queue                                    │  │
│  │  - capacity: int                                         │  │
│  │                                                          │  │
│  │  方法:                                                   │  │
│  │  - insert(transition) → 自动发送到 Learner              │  │
│  │  - latest_data_id() → int                               │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              ReplayBufferDataStore (Learner 端)          │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  继承: ReplayBuffer + DataStoreBase                      │  │
│  │                                                          │  │
│  │  属性:                                                   │  │
│  │  - dataset_dict: Dict[str, np.ndarray]                  │  │
│  │  - _size: int                                            │  │
│  │  - _capacity: int                                        │  │
│  │  - _insert_index: int                                    │  │
│  │  - _lock: Lock (线程安全)                                 │  │
│  │                                                          │  │
│  │  方法:                                                   │  │
│  │  - insert(transition) → None                            │  │
│  │  - sample(batch_size, ...) → Dict                        │  │
│  │  - get_iterator(...) → Iterator                          │  │
│  │  - latest_data_id() → int                                │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              MemoryEfficientReplayBufferDataStore       │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │                                                          │  │
│  │  继承: MemoryEfficientReplayBuffer + DataStoreBase      │  │
│  │                                                          │  │
│  │  特点:                                                   │  │
│  │  - 图像数据存储在磁盘（内存映射）                         │  │
│  │  - 状态数据存储在内存                                     │  │
│  │  - 支持大容量缓冲区（> 100K transitions）                │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 4. 与原项目对比

| 组件 | 原项目（真机） | 方案B（仿真） |
|------|---------------|---------------|
| **通信方式** | HTTP POST 请求 | HTTP POST 请求（保持一致） |
| **服务器** | Flask Server（独立进程） | Flask Server（独立进程，保持一致） |
| **机器人控制** | ROS1 消息 | Isaac Sim API |
| **相机** | RealSense 硬件 | Isaac Sim 虚拟相机 |
| **环境启动** | 外部启动 Flask | 外部启动 Flask（保持一致） |
| **部署方式** | 单机或分离 | **支持分离部署（两台主机）** |
| **数据管理** | Actor-Learner 架构 | **完全保持不变** |
| **训练流程** | RLPD 训练 | **完全保持不变** |

### 5. 架构优势

1. **架构一致性**：与真机环境保持相同的通信接口，代码复用性高
2. **资源分离**：仿真环境（GPU 密集）和策略训练（GPU 密集）可以部署在不同主机
3. **远程部署**：支持通过网络远程连接仿真环境
4. **易于调试**：Flask 服务器可以独立测试和调试
5. **数据管理不变**：Actor-Learner 架构和数据管理机制完全保持不变

## Flask 服务器转发的数据

### 当前项目（真机）Flask 服务器转发的数据

根据 `serl_robot_infra/robot_servers/franka_server.py` 和 `serl_robot_infra/franka_env/envs/franka_env.py` 的分析，Flask 服务器主要转发以下数据：

#### 1. 控制命令（Gym Env → Flask Server → ROS1/Isaac Sim）

| 端点 | 方法 | 数据格式 | 说明 |
|------|------|---------|------|
| `/pose` | POST | `{"arr": [x, y, z, qx, qy, qz, qw]}` | 发送末端执行器位姿命令（xyz + 四元数） |
| `/update_param` | POST | `{"param1": value1, ...}` | 更新阻抗控制器参数（仿真中可能不需要） |
| `/close_gripper` | POST | - | 关闭夹爪 |
| `/open_gripper` | POST | - | 打开夹爪 |
| `/move_gripper` | POST | `{"gripper_pos": 0-255}` | 移动夹爪到指定位置 |
| `/clearerr` | POST | - | 清除错误 |
| `/jointreset` | POST | - | 执行关节复位 |
| `/set_load` | POST | `{"mass": ..., "F_x_center_load": ..., "load_inertia": ...}` | 设置负载参数 |

#### 2. 状态查询（Gym Env ← Flask Server ← ROS1/Isaac Sim）

| 端点 | 方法 | 返回数据 | 说明 |
|------|------|---------|------|
| `/getstate` | POST | `{"pose": [...], "vel": [...], "force": [...], "torque": [...], "q": [...], "dq": [...], "jacobian": [...], "gripper_pos": ...}` | 获取所有机器人状态（最常用） |
| `/getpos` | POST | `{"pose": [x, y, z, qx, qy, qz, qw]}` | 获取末端执行器位姿 |
| `/getvel` | POST | `{"vel": [vx, vy, vz, wx, wy, wz]}` | 获取末端执行器速度 |
| `/getforce` | POST | `{"force": [fx, fy, fz]}` | 获取末端执行器力 |
| `/gettorque` | POST | `{"torque": [tx, ty, tz]}` | 获取末端执行器力矩 |
| `/getq` | POST | `{"q": [q1, ..., q7]}` | 获取关节位置 |
| `/getdq` | POST | `{"dq": [dq1, ..., dq7]}` | 获取关节速度 |
| `/getjacobian` | POST | `{"jacobian": [[...], ...]}` | 获取雅可比矩阵 |
| `/get_gripper` | POST | `{"gripper": pos}` | 获取夹爪位置 |

#### 3. 关键数据流

**控制流程**：
```
Gym Env.step() 
  → _send_pos_command(pose) 
    → requests.post(url + "pose", json={"arr": pose})
      → Flask Server: /pose
        → robot_server.move(pose)
          → ROS1: 发布到 /cartesian_impedance_controller/equilibrium_pose
            → Franka Robot
```

**状态查询流程**：
```
Gym Env._update_currpos()
  → requests.post(url + "getstate")
    → Flask Server: /getstate
      → robot_server.pos, vel, force, torque, q, dq, jacobian
        ← ROS1: 订阅 franka_state_controller/franka_states
          ← Franka Robot
```

### Isaac Sim 方案中的 Flask 转发

在 Isaac Sim 方案中，Flask 服务器将转发相同的数据，但后端从 ROS1 改为 Isaac Sim API：

**控制流程**：
```
Gym Env.step() 
  → _send_pos_command(pose) 
    → requests.post(url + "pose", json={"arr": pose})
      → Flask Server: /pose
        → isaac_sim_server.set_robot_pose(pose)
          → Isaac Sim API: franka.set_joint_position_targets(...)
            → Isaac Sim Simulation
```

**状态查询流程**：
```
Gym Env._update_currpos()
  → requests.post(url + "getstate")
    → Flask Server: /getstate
      → isaac_sim_server.get_state()
        → Isaac Sim API: 获取机器人状态
          ← Isaac Sim Simulation
```

## 实现方案

### 1. Flask 服务器实现（Isaac Sim Server）

Flask 服务器作为独立进程运行，管理 Isaac Sim 仿真环境：

```python
# serl_robot_infra/robot_servers/isaac_sim_server.py

"""
Isaac Sim Flask Server
独立进程运行，管理 Isaac Sim 仿真环境
"""
from flask import Flask, request, jsonify
import numpy as np
import threading
import time
from absl import app, flags
from scipy.spatial.transform import Rotation as R

# 必须在导入其他 Isaac Sim 模块之前启动 SimulationApp
from omni.isaac.kit import SimulationApp

FLAGS = flags.FLAGS
flags.DEFINE_string("flask_url", "127.0.0.1", "URL for the flask server to run on.")
flags.DEFINE_integer("flask_port", 5001, "Port for the flask server to run on.")
flags.DEFINE_bool("headless", True, "Run Isaac Sim in headless mode.")
flags.DEFINE_integer("sim_width", 1280, "Simulation window width.")
flags.DEFINE_integer("sim_height", 720, "Simulation window height.")


class IsaacSimServer:
    """管理 Isaac Sim 仿真环境"""
    
    def __init__(self, headless=True, width=1280, height=720):
        # 启动 Isaac Sim
        config = {
            "headless": headless,
            "width": width,
            "height": height,
        }
        self.simulation_app = SimulationApp(config)
        
        # 现在可以导入其他模块
        from omni.isaac.core import World
        from omni.isaac.franka import Franka
        from omni.isaac.sensor import Camera
        
        # 创建世界
        self.world = World(stage_units_in_meters=1.0)
        self.world.set_physics_dt(1.0 / 60.0)  # 60 Hz
        self.world.scene.add_default_ground_plane()
        
        # 添加机器人
        self.franka = self.world.scene.add(
            Franka(
                prim_path="/World/franka",
                name="franka",
                position=np.array([0, 0, 0]),
            )
        )
        
        # 添加相机（可选，根据配置）
        self.cameras = {}
        
        # 状态变量
        self.pos = np.zeros(7)  # xyz + quat
        self.vel = np.zeros(6)
        self.force = np.zeros(3)
        self.torque = np.zeros(3)
        self.q = np.zeros(7)
        self.dq = np.zeros(7)
        self.jacobian = np.zeros((6, 7))
        self.gripper_pos = 0.0
        
        # IK 控制器（需要实现或使用 Isaac Sim 的控制器）
        self._setup_controller()
        
        # 初始化世界
        self.world.reset()
        
        # 启动仿真循环线程
        self.running = True
        self.sim_thread = threading.Thread(target=self._simulation_loop)
        self.sim_thread.daemon = True
        self.sim_thread.start()
        
        print("[INFO] Isaac Sim Server initialized")
    
    def _setup_controller(self):
        """设置机器人控制器（IK 求解器）"""
        # TODO: 实现 IK 控制器
        # 可以使用 RMPFlowController 或自定义 IK 求解器
        pass
    
    def _simulation_loop(self):
        """仿真循环（在独立线程中运行）"""
        while self.running and self.simulation_app.is_running():
            # 步进物理仿真
            self.world.step(render=not self.simulation_app.config.get("headless", True))
            
            # 更新状态
            self._update_state()
            
            # 控制频率
            time.sleep(1.0 / 60.0)  # 60 Hz
    
    def _update_state(self):
        """更新机器人状态"""
        from omni.isaac.core.utils.stage import get_current_stage
        from pxr import UsdGeom
        
        try:
            # 获取末端执行器位姿
            stage = get_current_stage()
            ee_prim = stage.GetPrimAtPath("/World/franka/panda_hand")
            xform = UsdGeom.Xformable(ee_prim)
            world_transform = xform.ComputeLocalToWorldTransform(0)
            
            position = np.array(world_transform.ExtractTranslation())
            rotation_matrix = world_transform.ExtractRotationMatrix()
            rotation = R.from_matrix(rotation_matrix).as_quat()
            
            self.pos = np.concatenate([position, rotation])
            
            # 获取关节状态
            self.q = self.franka.get_joint_positions()
            self.dq = self.franka.get_joint_velocities()
            
            # 计算末端执行器速度（通过雅可比）
            # TODO: 计算雅可比矩阵
            # self.jacobian = compute_jacobian(...)
            # self.vel = self.jacobian @ self.dq
            
            # 获取力/力矩（需要添加力传感器）
            # TODO: 实现力/力矩获取
            
        except Exception as e:
            print(f"[WARNING] Failed to update state: {e}")
    
    def set_pose(self, pose: np.ndarray):
        """设置机器人末端执行器位姿"""
        # TODO: 实现 IK 求解
        # 方法1：使用控制器
        # self.controller.set_target_pose(pose[:3], pose[3:])
        # joint_targets = self.controller.compute()
        # self.franka.set_joint_position_targets(joint_targets)
        
        # 方法2：使用 IK 求解器
        # joint_targets = self.ik_solver.compute(pose)
        # self.franka.set_joint_position_targets(joint_targets)
        
        pass
    
    def get_state(self):
        """获取所有机器人状态"""
        return {
            "pose": self.pos.tolist(),
            "vel": self.vel.tolist(),
            "force": self.force.tolist(),
            "torque": self.torque.tolist(),
            "q": self.q.tolist(),
            "dq": self.dq.tolist(),
            "jacobian": self.jacobian.tolist(),
            "gripper_pos": self.gripper_pos,
        }
    
    def set_gripper(self, gripper_pos: float):
        """设置夹爪位置"""
        # TODO: 实现夹爪控制
        # 可能需要控制夹爪关节
        self.gripper_pos = gripper_pos
    
    def close(self):
        """关闭服务器"""
        self.running = False
        if self.sim_thread.is_alive():
            self.sim_thread.join(timeout=1.0)
        if self.simulation_app is not None:
            self.simulation_app.close()
        print("[INFO] Isaac Sim Server closed")


def main(_):
    webapp = Flask(__name__)
    
    # 初始化 Isaac Sim 服务器
    isaac_sim_server = IsaacSimServer(
        headless=FLAGS.headless,
        width=FLAGS.sim_width,
        height=FLAGS.sim_height,
    )
    
    # Flask 路由（与原项目 franka_server.py 保持一致）
    
    @webapp.route("/pose", methods=["POST"])
    def pose():
        pos = np.array(request.json["arr"])
        isaac_sim_server.set_pose(pos)
        return "Moved"
    
    @webapp.route("/getstate", methods=["POST"])
    def get_state():
        return jsonify(isaac_sim_server.get_state())
    
    @webapp.route("/getpos", methods=["POST"])
    def get_pos():
        return jsonify({"pose": isaac_sim_server.pos.tolist()})
    
    @webapp.route("/getvel", methods=["POST"])
    def get_vel():
        return jsonify({"vel": isaac_sim_server.vel.tolist()})
    
    @webapp.route("/getforce", methods=["POST"])
    def get_force():
        return jsonify({"force": isaac_sim_server.force.tolist()})
    
    @webapp.route("/gettorque", methods=["POST"])
    def get_torque():
        return jsonify({"torque": isaac_sim_server.torque.tolist()})
    
    @webapp.route("/getq", methods=["POST"])
    def get_q():
        return jsonify({"q": isaac_sim_server.q.tolist()})
    
    @webapp.route("/getdq", methods=["POST"])
    def get_dq():
        return jsonify({"dq": isaac_sim_server.dq.tolist()})
    
    @webapp.route("/getjacobian", methods=["POST"])
    def get_jacobian():
        return jsonify({"jacobian": isaac_sim_server.jacobian.tolist()})
    
    @webapp.route("/get_gripper", methods=["POST"])
    def get_gripper():
        return jsonify({"gripper": isaac_sim_server.gripper_pos})
    
    @webapp.route("/close_gripper", methods=["POST"])
    def close_gripper():
        isaac_sim_server.set_gripper(0.0)
        return "Closed"
    
    @webapp.route("/open_gripper", methods=["POST"])
    def open_gripper():
        isaac_sim_server.set_gripper(1.0)
        return "Opened"
    
    @webapp.route("/move_gripper", methods=["POST"])
    def move_gripper():
        gripper_pos = request.json["gripper_pos"]
        isaac_sim_server.set_gripper(gripper_pos)
        return "Moved Gripper"
    
    @webapp.route("/clearerr", methods=["POST"])
    def clear():
        # 仿真中可能不需要清除错误
        return "Clear"
    
    @webapp.route("/update_param", methods=["POST"])
    def update_param():
        # 仿真中可能不需要更新参数
        return "Updated"
    
    @webapp.route("/jointreset", methods=["POST"])
    def joint_reset():
        # TODO: 实现关节复位
        return "Reset Joint"
    
    try:
        webapp.run(host=FLAGS.flask_url, port=FLAGS.flask_port)
    except KeyboardInterrupt:
        print("\n[INFO] Shutting down...")
    finally:
        isaac_sim_server.close()


if __name__ == "__main__":
    app.run(main)
```

### 2. Gym 环境实现（Isaac Sim Env）

Gym 环境通过 HTTP 请求与 Flask 服务器通信，接口与原项目 `franka_env.py` 保持一致：

```python
# serl_robot_infra/franka_env/envs/isaac_sim_env.py

"""
Isaac Sim Franka 环境
通过 HTTP 请求与 Flask 服务器通信
"""
import numpy as np
import gymnasium as gym
import cv2
import copy
import time
import requests
from scipy.spatial.transform import Rotation
from typing import Dict, Tuple

from franka_env.envs.franka_env import DefaultEnvConfig
from franka_env.utils.rotations import euler_2_quat, quat_2_euler


class IsaacSimFrankaEnv(gym.Env):
    """
    Isaac Sim Franka 环境
    
    通过 Flask 服务器与 Isaac Sim 通信，接口与原项目 franka_env.py 保持一致
    """
    
    def __init__(
        self,
        hz=10,
        fake_env=False,
        save_video=False,
        config: DefaultEnvConfig = None,
    ):
        self.config = config
        self.hz = hz
        self.fake_env = fake_env
        self.save_video = save_video
        self.max_episode_length = config.MAX_EPISODE_LENGTH
        self.display_image = config.DISPLAY_IMAGE
        
        # Flask 服务器 URL
        self.url = config.SERVER_URL  # 例如: "http://127.0.0.1:5001/"
        
        # 动作缩放
        self.action_scale = config.ACTION_SCALE
        
        # 位姿配置
        self._TARGET_POSE = config.TARGET_POSE
        self._RESET_POSE = config.RESET_POSE
        self._REWARD_THRESHOLD = config.REWARD_THRESHOLD
        
        # 随机重置配置
        self.randomreset = config.RANDOM_RESET
        self.random_xy_range = config.RANDOM_XY_RANGE
        self.random_rz_range = config.RANDOM_RZ_RANGE
        
        # 转换 RESET_POSE 为四元数格式
        self.resetpos = np.concatenate(
            [config.RESET_POSE[:3], euler_2_quat(config.RESET_POSE[3:])]
        )
        
        # 边界框
        self.xyz_bounding_box = gym.spaces.Box(
            config.ABS_POSE_LIMIT_LOW[:3],
            config.ABS_POSE_LIMIT_HIGH[:3],
            dtype=np.float64,
        )
        self.rpy_bounding_box = gym.spaces.Box(
            config.ABS_POSE_LIMIT_LOW[3:],
            config.ABS_POSE_LIMIT_HIGH[3:],
            dtype=np.float64,
        )
        
        # 定义动作和观察空间
        self.action_space = gym.spaces.Box(
            low=-1.0, high=1.0, shape=(7,), dtype=np.float32
        )
        self.observation_space = self._get_observation_space()
        
        # 状态变量
        self.currpos = None
        self.currvel = None
        self.currforce = None
        self.currtorque = None
        self.curr_gripper_pos = None
        self.curr_path_length = 0
        self.terminate = False
        
        # 视频录制
        if self.save_video:
            self.recording_frames = []
        
        # 初始化状态
        self._update_currpos()
        
        print(f"Initialized Isaac Sim Franka Environment (Server: {self.url})")
    
    def _get_observation_space(self):
        """定义观察空间"""
        return gym.spaces.Dict({
            "state": gym.spaces.Dict({
                "tcp_pose": gym.spaces.Box(-np.inf, np.inf, shape=(7,)),
                "tcp_vel": gym.spaces.Box(-np.inf, np.inf, shape=(6,)),
                "gripper_pose": gym.spaces.Box(-1, 1, shape=(1,)),
                "tcp_force": gym.spaces.Box(-np.inf, np.inf, shape=(3,)),
                "tcp_torque": gym.spaces.Box(-np.inf, np.inf, shape=(3,)),
            }),
            "images": gym.spaces.Dict({
                key: gym.spaces.Box(0, 255, shape=(128, 128, 3), dtype=np.uint8)
                for key in self.config.REALSENSE_CAMERAS.keys()
            }),
        })
    
    def _send_pos_command(self, pos: np.ndarray):
        """发送位置命令（与原项目保持一致）"""
        arr = np.array(pos).astype(np.float32)
        data = {"arr": arr.tolist()}
        requests.post(self.url + "pose", json=data)
    
    def _send_gripper_command(self, pos: float, mode="binary"):
        """发送夹爪命令（与原项目保持一致）"""
        if mode == "binary":
            if pos <= -0.5 and self.curr_gripper_pos > 0.85:
                requests.post(self.url + "close_gripper")
            elif pos >= 0.5 and self.curr_gripper_pos < 0.85:
                requests.post(self.url + "open_gripper")
        elif mode == "continuous":
            # TODO: 实现连续夹爪控制
            pass
    
    def _update_currpos(self):
        """更新当前位置和状态（与原项目保持一致）"""
        ps = requests.post(self.url + "getstate").json()
        self.currpos = np.array(ps["pose"])
        self.currvel = np.array(ps["vel"])
        self.currforce = np.array(ps["force"])
        self.currtorque = np.array(ps["torque"])
        self.curr_gripper_pos = np.array(ps["gripper_pos"])
    
    def _get_images(self) -> Dict[str, np.ndarray]:
        """获取相机图像"""
        # TODO: 从 Flask 服务器获取图像
        # 方法1：添加 /get_images 端点
        # 方法2：使用 WebSocket 实时传输
        # 临时实现：返回零图像
        images = {}
        for cam_key in self.config.REALSENSE_CAMERAS.keys():
            images[cam_key] = np.zeros((128, 128, 3), dtype=np.uint8)
        return images
    
    def _get_obs(self) -> Dict:
        """获取观察"""
        images = self._get_images()
        state_obs = {
            "tcp_pose": self.currpos,
            "tcp_vel": self.currvel,
            "gripper_pose": self.curr_gripper_pos,
            "tcp_force": self.currforce,
            "tcp_torque": self.currtorque,
        }
        return copy.deepcopy({
            "images": images,
            "state": state_obs,
        })
    
    def step(self, action: np.ndarray) -> Tuple[Dict, float, bool, bool, Dict]:
        """执行一步动作（与原项目保持一致）"""
        start_time = time.time()
        
        # 1. 处理动作
        action = np.clip(action, self.action_space.low, self.action_space.high)
        
        # 2. 计算目标位姿
        xyz_delta = action[:3] * self.action_scale[0]
        rot_delta = action[3:6] * self.action_scale[1]
        
        self.nextpos = self.currpos.copy()
        self.nextpos[:3] = self.nextpos[:3] + xyz_delta
        
        # 更新姿态
        current_rot = Rotation.from_quat(self.currpos[3:])
        delta_rot = Rotation.from_rotvec(rot_delta)
        target_rot = delta_rot * current_rot
        self.nextpos[3:] = target_rot.as_quat()
        
        # 3. 发送命令
        gripper_action = action[6] * self.action_scale[2]
        self._send_gripper_command(gripper_action)
        self._send_pos_command(self.clip_safety_box(self.nextpos))
        
        # 4. 控制频率
        dt = time.time() - start_time
        time.sleep(max(0, (1.0 / self.hz) - dt))
        
        # 5. 更新状态
        self._update_currpos()
        self.curr_path_length += 1
        
        # 6. 获取观察
        obs = self._get_obs()
        
        # 7. 计算奖励
        reward = self.compute_reward(obs)
        
        # 8. 检查是否完成
        done = (
            self.curr_path_length >= self.max_episode_length
            or reward > 0
            or self.terminate
        )
        
        info = {"succeed": bool(reward)}
        return obs, float(reward), done, False, info
    
    def reset(self, **kwargs) -> Tuple[Dict, Dict]:
        """重置环境"""
        if self.save_video and hasattr(self, 'recording_frames') and len(self.recording_frames) > 0:
            self.save_video_recording()
        
        # 发送重置命令
        requests.post(self.url + "update_param", json=self.config.COMPLIANCE_PARAM)
        
        # 执行关节复位（如果需要）
        # requests.post(self.url + "jointreset")
        
        # 移动到重置位姿
        reset_pose = self._get_reset_pose()
        self.interpolate_move(reset_pose, timeout=1.0)
        
        # 更新状态
        self._update_currpos()
        self.curr_path_length = 0
        self.terminate = False
        
        # 获取观察
        obs = self._get_obs()
        
        return obs, {"succeed": False}
    
    def interpolate_move(self, goal: np.ndarray, timeout: float):
        """线性插值移动到目标位置（与原项目保持一致）"""
        if goal.shape == (6,):
            goal = np.concatenate([goal[:3], euler_2_quat(goal[3:])])
        steps = int(timeout * self.hz)
        self._update_currpos()
        path = np.linspace(self.currpos, goal, steps)
        for p in path:
            self._send_pos_command(p)
            time.sleep(1 / self.hz)
        self.nextpos = p
        self._update_currpos()
    
    def _get_reset_pose(self) -> np.ndarray:
        """获取重置位姿（支持随机化）"""
        reset_pose = self.resetpos.copy()
        
        if self.randomreset:
            reset_pose[:2] += np.random.uniform(
                -self.random_xy_range,
                self.random_xy_range,
                (2,)
            )
            
            euler_random = self._RESET_POSE[3:].copy()
            euler_random[-1] += np.random.uniform(
                -self.random_rz_range,
                self.random_rz_range
            )
            reset_pose[3:] = euler_2_quat(euler_random)
        
        return reset_pose
    
    def compute_reward(self, obs) -> bool:
        """计算奖励（与原项目保持一致）"""
        current_pose = obs["state"]["tcp_pose"]
        
        current_rot = Rotation.from_quat(current_pose[3:]).as_matrix()
        target_rot = Rotation.from_euler("xyz", self._TARGET_POSE[3:]).as_matrix()
        diff_rot = current_rot.T @ target_rot
        diff_euler = Rotation.from_matrix(diff_rot).as_euler("xyz")
        delta = np.abs(np.hstack([
            current_pose[:3] - self._TARGET_POSE[:3],
            diff_euler
        ]))
        
        if np.all(delta < self._REWARD_THRESHOLD):
            return 1.0
        return 0.0
    
    def clip_safety_box(self, pose: np.ndarray) -> np.ndarray:
        """裁剪到安全边界框内（与原项目保持一致）"""
        pose[:3] = np.clip(
            pose[:3],
            self.xyz_bounding_box.low,
            self.xyz_bounding_box.high
        )
        
        euler = Rotation.from_quat(pose[3:]).as_euler("xyz")
        
        sign = np.sign(euler[0])
        euler[0] = sign * np.clip(
            np.abs(euler[0]),
            self.rpy_bounding_box.low[0],
            self.rpy_bounding_box.high[0],
        )
        
        euler[1:] = np.clip(
            euler[1:],
            self.rpy_bounding_box.low[1:],
            self.rpy_bounding_box.high[1:]
        )
        
        pose[3:] = Rotation.from_euler("xyz", euler).as_quat()
        
        return pose
    
    def close(self):
        """关闭环境"""
        pass
```

## 双机部署架构

### 1. 部署架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        主机1：仿真环境主机                                │
│                    (GPU 1: Isaac Sim 专用)                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                    Isaac Sim Flask Server                      │  │
│  ├─────────────────────────────────────────────────────────────────┤  │
│  │                                                                 │  │
│  │  - Isaac Sim Simulation (GPU 1)                                │  │
│  │  - Flask HTTP Server (Port 5001)                               │  │
│  │  - 仿真循环线程 (60 Hz)                                         │  │
│  │  - 状态更新线程                                                 │  │
│  │                                                                 │  │
│  │  资源占用:                                                      │  │
│  │  - GPU: ~80-90% (渲染 + 物理仿真)                               │  │
│  │  - CPU: ~30-40% (物理计算)                                      │  │
│  │  - 内存: ~8-12 GB (场景 + 缓冲区)                                │  │
│  └─────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  网络接口:                                                              │
│  - IP: 192.168.1.100 (示例)                                            │
│  - 端口: 5001 (Flask HTTP)                                            │
│  - 防火墙: 开放 5001 端口                                               │
└─────────────────────────────────────────────────────────────────────────┘
                              │
                              │ 网络 (千兆以太网)
                              │ HTTP POST/GET
                              │
┌─────────────────────────────┼─────────────────────────────────────────────┐
│                             │           主机2：训练主机                    │
│                             │        (GPU 2: 训练专用)                    │
├─────────────────────────────┼─────────────────────────────────────────────┤
│                             │                                             │
│  ┌──────────────────────────▼─────────────────────────────────────┐     │
│  │                    Actor 进程                                  │     │
│  ├────────────────────────────────────────────────────────────────┤     │
│  │                                                                 │     │
│  │  - IsaacSimFrankaEnv (Gym Environment)                        │     │
│  │  - HTTP Client (requests)                                      │     │
│  │  - 数据收集 (QueuedDataStore)                                  │     │
│  │                                                                 │     │
│  │  资源占用:                                                      │     │
│  │  - GPU: ~5-10% (图像处理)                                       │     │
│  │  - CPU: ~20-30% (环境交互)                                      │     │
│  │  - 内存: ~2-4 GB                                                │     │
│  └──────────────────────────┬─────────────────────────────────────┘     │
│                              │                                             │
│                              │ TrainerClient (TCP/IP)                     │
│                              │                                             │
│  ┌──────────────────────────▼─────────────────────────────────────┐     │
│  │                    Learner 进程                                │     │
│  ├────────────────────────────────────────────────────────────────┤     │
│  │                                                                 │     │
│  │  - SAC Agent (模型训练)                                         │     │
│  │  - TrainerServer (TCP/IP)                                      │     │
│  │  - ReplayBuffer (数据管理)                                      │     │
│  │                                                                 │     │
│  │  资源占用:                                                      │     │
│  │  - GPU: ~70-85% (模型训练)                                      │     │
│  │  - CPU: ~40-50% (数据处理)                                      │     │
│  │  - 内存: ~16-32 GB (缓冲区 + 模型)                               │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                           │
│  网络接口:                                                                │
│  - IP: 192.168.1.101 (示例)                                              │
│  - 端口: 随机 (TrainerServer)                                            │
│  - 防火墙: 开放 TrainerServer 端口                                       │
└───────────────────────────────────────────────────────────────────────────┘
```

### 2. 网络拓扑

```
┌──────────────────────────────────────────────────────────────────────┐
│                        网络配置                                       │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  主机1 (仿真)             主机2 (训练)                               │
│  192.168.1.100           192.168.1.101                              │
│  ──────────────          ──────────────                              │
│        │                       │                                      │
│        │                       │                                      │
│        └───────────┬───────────┘                                      │
│                    │                                                  │
│            ┌───────▼───────┐                                          │
│            │  千兆以太网    │                                          │
│            │  交换机/路由器 │                                          │
│            └───────────────┘                                          │
│                                                                      │
│  通信协议:                                                            │
│  - HTTP (Flask): 主机2 → 主机1 (控制命令/状态查询)                     │
│  - TCP/IP (TrainerServer): 主机2 Actor ↔ 主机2 Learner (数据同步)   │
│                                                                      │
│  端口配置:                                                            │
│  - 主机1: 5001 (Flask HTTP)                                          │
│  - 主机2: 随机端口 (TrainerServer, 由 agentlace 管理)                 │
└──────────────────────────────────────────────────────────────────────┘
```

### 3. 部署步骤

#### 3.1 主机1（仿真环境主机）配置

**步骤1：安装 Isaac Sim**
```bash
# 安装 Isaac Sim (参考 NVIDIA 官方文档)
# 确保 GPU 驱动和 CUDA 版本兼容
```

**步骤2：配置环境**
```bash
# 创建 conda 环境
conda create -n hilserl python=3.10
conda activate hilserl

# 安装依赖
cd serl_robot_infra
pip install -e .
```

**步骤3：启动 Flask 服务器**
```bash
# 创建启动脚本 launch_isaac_sim_server.sh
#!/bin/bash
cd serl_robot_infra/robot_servers
conda activate hilserl
python isaac_sim_server.py \
    --flask_url=0.0.0.0 \
    --flask_port=5001 \
    --headless=True \
    --sim_width=1280 \
    --sim_height=720

# 运行
chmod +x launch_isaac_sim_server.sh
./launch_isaac_sim_server.sh
```

**步骤4：配置防火墙**
```bash
# Ubuntu/Debian
sudo ufw allow 5001/tcp

# CentOS/RHEL
sudo firewall-cmd --add-port=5001/tcp --permanent
sudo firewall-cmd --reload
```

#### 3.2 主机2（训练主机）配置

**步骤1：配置环境**
```bash
# 创建 conda 环境
conda create -n hilserl python=3.10
conda activate hilserl

# 安装依赖
cd serl_launcher
pip install -e .
cd ../serl_robot_infra
pip install -e .
```

**步骤2：配置环境 URL**
```python
# examples/experiments/ram_insertion/config.py
class TrainConfig(DefaultTrainingConfig):
    # ... 其他配置 ...
    
    # 设置远程 Flask 服务器 URL
    SERVER_URL = "http://192.168.1.100:5001/"  # 主机1的IP
```

**步骤3：启动训练**
```bash
# 启动 Learner
python examples/train_rlpd.py \
    --exp_name=ram_insertion \
    --learner=True \
    --ip=127.0.0.1 \
    --checkpoint_path=./checkpoints

# 启动 Actor (另一个终端)
python examples/train_rlpd.py \
    --exp_name=ram_insertion \
    --actor=True \
    --ip=127.0.0.1 \
    --checkpoint_path=./checkpoints
```

### 4. 网络性能要求

#### 4.1 延迟要求

| 操作 | 最大延迟 | 说明 |
|------|---------|------|
| 控制命令 (`/pose`) | < 50ms | 影响控制频率 |
| 状态查询 (`/getstate`) | < 50ms | 影响观察更新 |
| 图像传输 (`/get_images`) | < 100ms | 影响视觉观察 |

**建议**：
- 使用千兆以太网（1 Gbps）
- 延迟 < 10ms（局域网）
- 避免跨网络（如 VPN）

#### 4.2 带宽要求

| 数据类型 | 频率 | 数据大小 | 带宽需求 |
|---------|------|---------|---------|
| 控制命令 | 10 Hz | ~100 bytes | ~1 KB/s |
| 状态查询 | 10 Hz | ~500 bytes | ~5 KB/s |
| 图像数据 | 10 Hz | ~150 KB (128x128x3) | ~1.5 MB/s |

**总带宽需求**：约 2-3 MB/s（单 Actor）

**优化建议**：
- 图像压缩（JPEG 质量 80-90%）
- 降低图像分辨率（128x128 → 64x64）
- 使用 WebSocket 替代 HTTP（减少开销）

### 5. 资源分配建议

#### 5.1 主机1（仿真环境）

| 资源 | 推荐配置 | 说明 |
|------|---------|------|
| GPU | NVIDIA RTX 3090/4090 或 A100 | 渲染 + 物理仿真 |
| CPU | 8+ 核心 | 物理计算 |
| 内存 | 16+ GB | 场景 + 缓冲区 |
| 存储 | 50+ GB SSD | Isaac Sim 安装 |

#### 5.2 主机2（训练主机）

| 资源 | 推荐配置 | 说明 |
|------|---------|------|
| GPU | NVIDIA RTX 3090/4090 或 A100 | 模型训练 |
| CPU | 16+ 核心 | 数据处理 |
| 内存 | 32+ GB | 缓冲区 + 模型 |
| 存储 | 100+ GB SSD | 检查点 + 数据 |

### 6. 监控和调试

#### 6.1 网络监控

```bash
# 监控网络延迟
ping 192.168.1.100

# 监控带宽使用
iftop -i eth0

# 监控端口连接
netstat -an | grep 5001
```

#### 6.2 Flask 服务器监控

```python
# 在 isaac_sim_server.py 中添加日志
import logging
logging.basicConfig(level=logging.INFO)

@app.route("/health", methods=["GET"])
def health():
    return jsonify({
        "status": "healthy",
        "simulation_running": isaac_sim_server.running,
        "queue_size": len(isaac_sim_server.command_queue),
    })
```

#### 6.3 训练监控

```python
# 使用 wandb 监控训练
wandb.init(project="hil-serl", config=config)

# 记录网络延迟
wandb.log({"network_latency": latency_ms})
```

## 单机部署（开发和测试）

在同一台主机上运行 Flask 服务器和训练脚本：

**主机1（GPU 主机）**：
```bash
# 启动 Isaac Sim Flask 服务器
cd serl_robot_infra/robot_servers
conda activate hilserl
python isaac_sim_server.py \
    --flask_url=127.0.0.1 \
    --flask_port=5001 \
    --headless=True
```

**训练脚本**（同一主机）：
```python
# 在配置中设置服务器 URL
config.SERVER_URL = "http://127.0.0.1:5001/"
env = IsaacSimFrankaEnv(config=config)
```

## 关键实现点

### 1. Flask 服务器管理

- **独立进程**：Flask 服务器作为独立进程运行，管理 Isaac Sim 生命周期
- **仿真循环**：在独立线程中运行仿真循环，避免阻塞 HTTP 请求
- **状态同步**：定期更新机器人状态，供 HTTP 请求查询

### 2. 接口兼容性

- **API 兼容**：Flask 路由与原项目 `franka_server.py` 保持一致
- **数据格式**：请求和响应格式与原项目完全一致
- **代码复用**：Gym 环境代码可以最大程度复用

### 3. 待实现功能

1. **机器人位姿控制** (`IsaacSimServer.set_pose`)
   - 需要实现 IK 求解或使用控制器
   - 推荐使用 `RMPFlowController` 或 `InverseKinematicsSolver`

2. **状态获取** (`IsaacSimServer._update_state`)
   - 使用 USD API 获取末端执行器位姿
   - 实现速度、力/力矩获取
   - 计算雅可比矩阵

3. **夹爪控制** (`IsaacSimServer.set_gripper`)
   - 实现夹爪关节控制

4. **图像传输** (`IsaacSimFrankaEnv._get_images`)
   - 方法1：添加 `/get_images` 端点，通过 HTTP 传输
   - 方法2：使用 WebSocket 实时传输（推荐，性能更好）

## 与原实现的区别

| 方面 | 原项目（真机） | 方案B（仿真） |
|------|---------------|---------------|
| **启动方式** | Flask Server + ROS1 | Flask Server + Isaac Sim |
| **通信方式** | HTTP POST 请求 | HTTP POST 请求（保持一致） |
| **后端** | ROS1 → Franka Robot | Isaac Sim API → Simulation |
| **部署** | 单机或分离 | **支持分离部署（两台主机）** |
| **代码复用** | - | **Gym 环境代码高度复用** |

## 下一步工作

1. **实现核心方法**
   - `IsaacSimServer.set_pose()` - 使用 IK 或控制器
   - `IsaacSimServer._update_state()` - 完善状态获取
   - `IsaacSimServer.set_gripper()` - 实现夹爪控制
   - `IsaacSimFrankaEnv._get_images()` - 实现图像传输

2. **测试验证**
   - Flask 服务器独立测试
   - 环境创建和基本功能测试
   - 网络通信测试（分离部署）
   - 与训练脚本集成测试

3. **性能优化**
   - 图像传输优化（压缩、WebSocket）
   - 网络延迟优化
   - 仿真频率优化

4. **错误处理**
   - 网络连接错误处理
   - 仿真错误恢复
   - 超时处理

## 架构实现可能面临的问题

### 1. 技术问题

#### 1.1 Isaac Sim API 兼容性问题

**问题描述**：
- Isaac Sim 版本更新可能导致 API 变化
- 不同版本的 API 接口可能不兼容

**解决方案**：
- 固定 Isaac Sim 版本（如 2023.1.1）
- 使用虚拟环境隔离依赖
- 编写 API 兼容性测试

**代码示例**：
```python
# 版本检查
import omni.isaac.kit
print(f"Isaac Sim version: {omni.isaac.kit.__version__}")

# API 兼容性测试
try:
    from omni.isaac.core import World
    from omni.isaac.franka import Franka
except ImportError as e:
    raise RuntimeError(f"Isaac Sim API not available: {e}")
```

#### 1.2 IK 求解器实现问题

**问题描述**：
- Isaac Sim 可能没有现成的 IK 求解器
- 需要实现自定义 IK 或使用第三方库

**解决方案**：
- **方案1**：使用 Isaac Sim 的 `RMPFlowController`
- **方案2**：使用 `pybullet` 的 IK 求解器（作为中间层）
- **方案3**：实现基于雅可比的数值 IK

**代码示例**：
```python
# 方案1：使用 RMPFlowController
from omni.isaac.manipulators.controllers import RMPFlowController

controller = RMPFlowController(
    name="franka_controller",
    robot_articulation=self.franka,
    end_effector_prim_path="/World/franka/panda_hand",
)

# 方案2：使用 pybullet IK
import pybullet as p
joint_targets = p.calculateInverseKinematics(
    bodyUniqueId=robot_id,
    endEffectorLinkIndex=ee_link_index,
    targetPosition=target_pos,
    targetOrientation=target_quat,
)
```

#### 1.3 图像传输性能问题

**问题描述**：
- HTTP 传输图像数据延迟高
- 图像数据量大（128x128x3 = 49KB per image）
- 多相机场景下带宽需求高

**解决方案**：
- **方案1**：图像压缩（JPEG 质量 80-90%）
- **方案2**：使用 WebSocket 实时传输
- **方案3**：降低图像分辨率（128x128 → 64x64）
- **方案4**：图像缓存（只传输变化部分）

**代码示例**：
```python
# 方案1：JPEG 压缩
import cv2
encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 85]
_, img_encoded = cv2.imencode('.jpg', rgb_image, encode_param)
img_bytes = img_encoded.tobytes()

# Flask 端点
@app.route("/get_images", methods=["POST"])
def get_images():
    images = {}
    for cam_key, camera in isaac_sim_server.cameras.items():
        rgb = camera.get_rgba()[:, :, :3]
        _, img_encoded = cv2.imencode('.jpg', rgb, [cv2.IMWRITE_JPEG_QUALITY, 85])
        images[cam_key] = base64.b64encode(img_encoded).decode('utf-8')
    return jsonify(images)
```

#### 1.4 观察状态延迟问题（核心问题）

**问题本质**：

这不是频率不匹配的问题，而是**观察状态延迟**导致控制命令失效的问题。

**关键理解**：

1. **控制频率（10 Hz）**：这是发送控制命令的频率
   - 目的是让操控（策略控制或人为干预）没有明显延时
   - 每 100ms 发送一个控制命令
   - 代码：`time.sleep(max(0, (1.0 / self.hz) - dt))`，其中 `hz=10`

2. **物理仿真频率（60 Hz）**：这是物理世界运行的频率
   - 与控制命令没有必然联系
   - 只要仿真引擎能够正确反映执行控制命令的结果即可
   - 代码：`self.world.set_physics_dt(1.0 / 60.0)` 和 `world.step()`

3. **核心问题**：观察状态延迟
   - 控制命令是基于观察生成的：`action = agent.sample_actions(obs)`
   - 如果观察状态延迟，控制命令就会基于过时的状态，导致失效
   - 观察状态包括：机械臂本体状态（位姿、速度等）和图像数据

**原项目的处理方式**：

查看 `serl_robot_infra/franka_env/envs/franka_env.py` 的实现：

```python
def step(self, action: np.ndarray) -> tuple:
    start_time = time.time()
    # 1. 发送控制命令
    self._send_pos_command(self.clip_safety_box(self.nextpos))
    self._send_gripper_command(gripper_action)
    
    # 2. 控制频率（sleep 到 100ms）
    self.curr_path_length += 1
    dt = time.time() - start_time
    time.sleep(max(0, (1.0 / self.hz) - dt))
    
    # 3. 更新状态（在下一个控制周期开始时）
    self._update_currpos()  # HTTP 请求获取最新状态
    ob = self._get_obs()     # 获取观察（包括图像）
    
    return ob, reward, done, False, info
```

**原项目的延迟处理机制**：

1. **机械臂状态延迟处理**：
   - `_update_currpos()` 通过 HTTP POST 请求获取最新状态
   - 在发送命令后、下一个控制周期开始时更新状态
   - 确保获取的是执行命令后的最新状态

2. **图像数据延迟处理**（`video_capture.py`）：
   ```python
   class VideoCapture:
       def __init__(self, cap, name=None):
           self.q = queue.Queue()
           self.t = threading.Thread(target=self._reader)
           self.t.start()
       
       def _reader(self):
           while self.enable:
               ret, frame = self.cap.read()
               if not self.q.empty():
                   self.q.get_nowait()  # 丢弃旧帧
               self.q.put(frame)  # 只保留最新帧
       
       def read(self):
           return self.q.get(timeout=5)  # 获取最新帧
   ```
   - 使用队列和线程异步读取图像
   - **丢弃旧帧，只保留最新帧**，确保总是获取最新的图像数据
   - 避免图像延迟累积

**Isaac Sim 方案中的延迟问题**：

在 Isaac Sim 方案中，由于使用 Flask 服务器中转，会引入额外的延迟：

1. **网络延迟**：
   - HTTP 请求往返延迟（通常 5-20ms，取决于网络）
   - 可能比真机的本地通信延迟更高

2. **状态查询延迟**：
   - `_update_currpos()` 需要等待 HTTP 响应
   - 如果网络延迟高，可能导致状态过时

3. **图像传输延迟**：
   - 图像数据量大（128x128x3 = 49KB per image）
   - HTTP 传输可能比真机的本地读取慢

**时间线示例（原项目 vs Isaac Sim）**：

```
原项目（真机）：
时间轴 (ms)    训练 step()        真机状态
─────────────────────────────────────────────
0              step(0)
               ├─ 发送命令: pose_0 ──► ROS1 ──► 机器人执行
               ├─ sleep(100ms)
100            ├─ _update_currpos() ──► HTTP ──► 获取最新状态
               └─ _get_obs() ──► 本地读取图像（最新帧）
               step(1)
               ├─ 发送命令: pose_1 ──► ROS1 ──► 机器人执行
               └─ ...

Isaac Sim 方案：
时间轴 (ms)    训练 step()        Flask Server        仿真
─────────────────────────────────────────────────────────────
0              step(0)
               ├─ 发送命令: pose_0 ──► HTTP ──► /pose ──► 设置目标
               ├─ sleep(100ms)                              │
               │                                             │ 物理步进
               │                                             │ (60 Hz)
100            ├─ _update_currpos() ──► HTTP ──► /getstate ──► 获取状态
               │   (网络延迟: 5-20ms)                        │
               └─ _get_images() ──► HTTP ──► /get_images ──► 获取图像
                   (网络延迟: 10-50ms，取决于图像大小)
               step(1)
               └─ ...
```

**带来的影响**：

1. **观察状态延迟导致控制失效（核心问题）**
   - **问题**：控制命令基于观察生成，如果观察延迟，命令就会基于过时状态
   - **影响**：控制命令失效，导致训练不稳定
   - **示例**：
     ```
     t=0ms:   发送命令 pose_0（基于 obs_t0）
     t=100ms: 获取状态 obs_t100（执行 pose_0 后的状态）
     t=100ms: 基于 obs_t100 生成命令 pose_1
     
     但如果 _update_currpos() 延迟 20ms：
     t=100ms: 发送命令 pose_0
     t=120ms: 获取状态 obs_t120（延迟了 20ms）
     t=120ms: 基于 obs_t120 生成命令 pose_1
     
     问题：pose_1 基于的是 20ms 前的状态，可能已经过时
     ```

2. **图像数据延迟**
   - **问题**：图像传输延迟比真机的本地读取慢
   - **影响**：视觉观察延迟，影响基于视觉的策略
   - **示例**：
     ```
     真机：本地读取图像，延迟 < 5ms
     Isaac Sim：HTTP 传输图像，延迟 10-50ms（取决于网络和图像大小）
     
     如果图像延迟 30ms，视觉观察就是 30ms 前的状态
     ```

3. **状态查询延迟累积**
   - **问题**：每次 HTTP 请求都有延迟，可能累积
   - **影响**：观察状态越来越过时
   - **示例**：
     ```
     理想情况：每 100ms 更新一次状态
     实际情况：网络延迟 20ms，实际更新间隔 120ms
     累积效应：10 个 step 后，状态延迟 200ms
     ```

**解决方案**：

**核心原则**：确保观察状态（机械臂状态 + 图像）的延迟足够低，使得控制命令基于最新的状态。

**方案1：优化网络延迟（最重要）**

1. **使用本地网络**：
   - 单机部署：使用 `127.0.0.1`（延迟 < 1ms）
   - 双机部署：使用千兆以太网（延迟 < 10ms）

2. **HTTP 连接池**：
   ```python
   import requests
   from requests.adapters import HTTPAdapter
   
   # 创建连接池，复用连接
   session = requests.Session()
   adapter = HTTPAdapter(pool_connections=1, pool_maxsize=1)
   session.mount("http://", adapter)
   
   # 在环境中使用
   def _update_currpos(self):
       ps = session.post(self.url + "getstate", timeout=0.05).json()
       # ...
   ```

3. **并行请求**：
   ```python
   import concurrent.futures
   
   def _get_obs(self):
       with concurrent.futures.ThreadPoolExecutor() as executor:
           # 并行获取状态和图像
           state_future = executor.submit(self._update_currpos)
           images_future = executor.submit(self._get_images)
           
           state_future.result()
           images = images_future.result()
   ```

**方案2：状态缓存 + 最新帧机制（参考原项目）**

1. **状态缓存**（Flask 服务器端）：
   ```python
   class IsaacSimServer:
       def __init__(self):
           self.state_lock = threading.Lock()
           self.state_cache = {}  # 最新状态缓存
           
       def _simulation_loop(self):
           """仿真循环，持续更新状态缓存"""
           while self.running:
               self.world.step(render=False)
               
               # 持续更新状态缓存（不加锁，快速更新）
               self._update_state_fast()
               
               time.sleep(1.0 / 60.0)
       
       def _update_state_fast(self):
           """快速更新状态（不加锁，只更新必要字段）"""
           # 快速获取状态（避免加锁开销）
           self.pos = self._get_ee_pose_fast()
           self.vel = self._get_ee_vel_fast()
           # ...
       
       def get_state(self):
           """获取状态（加锁，确保一致性）"""
           with self.state_lock:
               return {
                   "pose": self.pos.tolist(),
                   "vel": self.vel.tolist(),
                   # ...
               }
   ```

2. **图像最新帧机制**（参考原项目的 VideoCapture）：
   ```python
   class IsaacSimServer:
       def __init__(self):
           self.image_queue = {}  # 每个相机的图像队列
           
       def _simulation_loop(self):
           """仿真循环，持续更新图像"""
           while self.running:
               self.world.step(render=False)
               
               # 更新图像（丢弃旧帧）
               for cam_key, camera in self.cameras.items():
                   rgb = camera.get_rgba()[:, :, :3]
                   if cam_key not in self.image_queue:
                       self.image_queue[cam_key] = queue.Queue(maxsize=1)
                   if not self.image_queue[cam_key].empty():
                       try:
                           self.image_queue[cam_key].get_nowait()  # 丢弃旧帧
                       except queue.Empty:
                           pass
                   self.image_queue[cam_key].put(rgb)  # 只保留最新帧
               
               time.sleep(1.0 / 60.0)
       
       def get_images(self):
           """获取最新图像"""
           images = {}
           for cam_key in self.cameras.keys():
               try:
                   images[cam_key] = self.image_queue[cam_key].get_nowait()
               except queue.Empty:
                   # 如果没有新图像，返回空（或上次的图像）
                   images[cam_key] = np.zeros((128, 128, 3), dtype=np.uint8)
           return images
   ```

**方案3：WebSocket 实时传输（高级方案）**

使用 WebSocket 替代 HTTP，实现实时双向通信：

```python
# Flask 服务器端
from flask_socketio import SocketIO, emit

socketio = SocketIO(app, cors_allowed_origins="*")

@socketio.on('get_state')
def handle_get_state():
    state = isaac_sim_server.get_state()
    emit('state_update', state)

@socketio.on('get_images')
def handle_get_images():
    images = isaac_sim_server.get_images()
    emit('images_update', images)

# Gym 环境端
import socketio

sio = socketio.Client()
sio.connect('http://192.168.1.100:5001')

def _update_currpos(self):
    sio.emit('get_state')
    # 等待响应（异步）
    @sio.on('state_update')
    def on_state(data):
        self.currpos = np.array(data['pose'])
```

**方案4：降低图像传输延迟**

1. **图像压缩**：
   ```python
   import cv2
   
   def get_images(self):
       images = {}
       for cam_key, camera in self.cameras.items():
           rgb = camera.get_rgba()[:, :, :3]
           # JPEG 压缩（质量 85）
           _, img_encoded = cv2.imencode('.jpg', rgb, [cv2.IMWRITE_JPEG_QUALITY, 85])
           images[cam_key] = base64.b64encode(img_encoded).decode('utf-8')
       return images
   ```

2. **降低分辨率**：
   ```python
   # 在 Flask 服务器端
   rgb = camera.get_rgba()[:, :, :3]
   rgb = cv2.resize(rgb, (64, 64))  # 降低到 64x64
   ```

**推荐实现（综合方案）**：

结合方案1和方案2，实现低延迟的状态和图像获取：

```python
class IsaacSimServer:
    def __init__(self):
        self.state_lock = threading.Lock()
        self.state_cache = {}
        self.image_queue = {}
        
    def _simulation_loop(self):
        """仿真循环，持续更新状态和图像"""
        while self.running:
            self.world.step(render=False)
            
            # 快速更新状态（不加锁）
            self._update_state_fast()
            
            # 更新图像（丢弃旧帧）
            self._update_images_fast()
            
            time.sleep(1.0 / 60.0)
    
    def get_state(self):
        """获取最新状态（加锁确保一致性）"""
        with self.state_lock:
            return copy.deepcopy(self.state_cache)
    
    def get_images(self):
        """获取最新图像（非阻塞）"""
        images = {}
        for cam_key in self.cameras.keys():
            try:
                images[cam_key] = self.image_queue[cam_key].get_nowait()
            except (queue.Empty, KeyError):
                images[cam_key] = np.zeros((128, 128, 3), dtype=np.uint8)
        return images
```

**延迟目标**：

参考原项目的延迟水平：
- **机械臂状态延迟**：< 20ms（HTTP 请求往返）
- **图像数据延迟**：< 30ms（包括传输和处理）
- **总观察延迟**：< 50ms（状态 + 图像）

**验证方法**：

```python
def test_observation_latency():
    env = IsaacSimFrankaEnv(config=config)
    
    # 测量状态更新延迟
    start = time.time()
    env._update_currpos()
    state_latency = (time.time() - start) * 1000  # ms
    
    # 测量图像获取延迟
    start = time.time()
    images = env._get_images()
    image_latency = (time.time() - start) * 1000  # ms
    
    print(f"State latency: {state_latency:.2f}ms")
    print(f"Image latency: {image_latency:.2f}ms")
    print(f"Total observation latency: {state_latency + image_latency:.2f}ms")
    
    # 目标：总延迟 < 50ms
    assert state_latency + image_latency < 50, \
        f"Observation latency too high: {state_latency + image_latency:.2f}ms"
```

### 2. 网络问题

#### 2.1 网络延迟问题

**问题描述**：
- 网络延迟导致控制命令延迟执行
- 状态查询延迟导致观察不准确
- 影响训练稳定性

**解决方案**：
- 使用本地网络（避免跨网络）
- 实现请求超时和重试机制
- 使用连接池减少连接开销
- 考虑使用 UDP（如果允许丢包）

**代码示例**：
```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# 创建带重试的会话
session = requests.Session()
retry_strategy = Retry(
    total=3,
    backoff_factor=0.1,
    status_forcelist=[500, 502, 503, 504],
)
adapter = HTTPAdapter(max_retries=retry_strategy)
session.mount("http://", adapter)

# 使用会话发送请求
def _send_pos_command(self, pos):
    try:
        response = session.post(
            self.url + "pose",
            json={"arr": pos.tolist()},
            timeout=0.1  # 100ms 超时
        )
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"Warning: Failed to send command: {e}")
```

#### 2.2 网络连接中断问题

**问题描述**：
- 网络连接中断导致训练失败
- 需要自动重连机制

**解决方案**：
- 实现连接健康检查
- 自动重连机制
- 优雅降级（使用缓存状态）

**代码示例**：
```python
class IsaacSimFrankaEnv(gym.Env):
    def __init__(self, ...):
        self.url = config.SERVER_URL
        self.connection_healthy = False
        self.cached_state = None
        
    def _check_connection(self):
        """检查连接健康"""
        try:
            response = requests.get(self.url + "health", timeout=1.0)
            self.connection_healthy = response.status_code == 200
        except:
            self.connection_healthy = False
        return self.connection_healthy
    
    def _update_currpos(self):
        """更新状态（带重试）"""
        if not self._check_connection():
            if self.cached_state is not None:
                # 使用缓存状态
                self.currpos = self.cached_state["pose"]
                return
            else:
                raise ConnectionError("Cannot connect to Flask server")
        
        try:
            ps = requests.post(self.url + "getstate", timeout=0.1).json()
            self.currpos = np.array(ps["pose"])
            self.cached_state = ps  # 更新缓存
        except requests.exceptions.RequestException as e:
            print(f"Warning: Failed to update state: {e}")
            if self.cached_state is not None:
                self.currpos = np.array(self.cached_state["pose"])
```

### 3. 性能问题

#### 3.1 GPU 资源竞争

**问题描述**：
- 单机部署时，Isaac Sim 和训练模型竞争 GPU
- 可能导致性能下降

**解决方案**：
- **双机部署**（推荐）：分离仿真和训练
- **GPU 分配**：使用 `CUDA_VISIBLE_DEVICES` 指定 GPU
- **优先级调整**：降低仿真渲染优先级

**代码示例**：
```bash
# 主机1：只使用 GPU 0（仿真）
CUDA_VISIBLE_DEVICES=0 python isaac_sim_server.py

# 主机2：只使用 GPU 0（训练）
CUDA_VISIBLE_DEVICES=0 python train_rlpd.py --learner=True
```

#### 3.2 内存占用问题

**问题描述**：
- Isaac Sim 占用大量内存（8-12 GB）
- ReplayBuffer 占用大量内存（16-32 GB）
- 可能导致 OOM（Out of Memory）

**解决方案**：
- 使用 `MemoryEfficientReplayBuffer`（图像存储在磁盘）
- 降低缓冲区容量
- 使用内存映射文件

**代码示例**：
```python
# 使用内存高效的缓冲区
from serl_launcher.data.data_store import MemoryEfficientReplayBufferDataStore

replay_buffer = MemoryEfficientReplayBufferDataStore(
    env.observation_space,
    env.action_space,
    capacity=100000,  # 降低容量
    image_keys=config.image_keys,
)
```

### 4. 数据一致性问题

#### 4.1 状态同步问题

**问题描述**：
- 多线程访问状态变量可能导致数据不一致
- 命令执行和状态查询可能不同步

**解决方案**：
- 使用线程锁保护共享状态
- 实现原子操作
- 使用状态快照

**代码示例**：
```python
class IsaacSimServer:
    def __init__(self):
        self.state_lock = threading.Lock()
        self.state_snapshot = {}
        
    def _update_state(self):
        """更新状态（加锁）"""
        with self.state_lock:
            # 更新状态
            self.pos = ...
            self.vel = ...
            # 创建快照
            self.state_snapshot = {
                "pose": self.pos.tolist(),
                "vel": self.vel.tolist(),
                ...
            }
    
    def get_state(self):
        """获取状态（加锁）"""
        with self.state_lock:
            return copy.deepcopy(self.state_snapshot)
```

#### 4.2 命令执行顺序问题

**问题描述**：
- 多个控制命令可能乱序执行
- 可能导致机器人状态不一致

**解决方案**：
- 使用命令队列（FIFO）
- 为每个命令添加时间戳
- 丢弃过期命令

**代码示例**：
```python
import time
from collections import deque

class IsaacSimServer:
    def __init__(self):
        self.command_queue = deque(maxlen=10)  # 限制队列大小
        
    def set_pose(self, pose):
        """添加命令到队列"""
        timestamp = time.time()
        self.command_queue.append(("pose", pose, timestamp))
    
    def _simulation_loop(self):
        """处理命令队列"""
        while self.running:
            # 处理队列中的命令
            while self.command_queue:
                cmd_type, cmd_data, timestamp = self.command_queue.popleft()
                
                # 丢弃过期命令（> 100ms）
                if time.time() - timestamp > 0.1:
                    continue
                
                if cmd_type == "pose":
                    self._apply_pose_command(cmd_data)
            
            self.world.step(render=False)
            time.sleep(1.0 / 60.0)
```

### 5. 调试和测试问题

#### 5.1 仿真环境难以调试

**问题描述**：
- 无头模式下无法可视化
- 错误信息不够详细

**解决方案**：
- 开发时使用非无头模式
- 添加详细日志
- 实现状态可视化工具

**代码示例**：
```python
# 添加详细日志
import logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class IsaacSimServer:
    def set_pose(self, pose):
        logger.debug(f"Setting pose: {pose}")
        try:
            # ... 执行命令 ...
            logger.debug("Pose set successfully")
        except Exception as e:
            logger.error(f"Failed to set pose: {e}", exc_info=True)
```

#### 5.2 单元测试困难

**问题描述**：
- Isaac Sim 需要 GPU 和特定环境
- 难以编写单元测试

**解决方案**：
- 使用 Mock 对象模拟 Isaac Sim API
- 编写集成测试（需要 GPU）
- 使用 CI/CD 自动化测试

**代码示例**：
```python
# Mock Isaac Sim
class MockIsaacSimServer:
    def __init__(self):
        self.pos = np.zeros(7)
        self.vel = np.zeros(6)
        
    def set_pose(self, pose):
        self.pos = pose
        
    def get_state(self):
        return {
            "pose": self.pos.tolist(),
            "vel": self.vel.tolist(),
            ...
        }

# 单元测试
def test_isaac_sim_env():
    mock_server = MockIsaacSimServer()
    env = IsaacSimFrankaEnv(config=config)
    env._isaac_sim_server = mock_server  # 注入 Mock
    
    obs, info = env.reset()
    assert obs is not None
```

### 6. 总结和建议

#### 6.1 优先级排序

1. **高优先级**：
   - IK 求解器实现
   - 网络延迟优化
   - 状态同步机制

2. **中优先级**：
   - 图像传输优化
   - 错误处理和重试
   - 性能监控

3. **低优先级**：
   - 单元测试
   - 文档完善
   - 可视化工具

#### 6.2 实施建议

1. **分阶段实施**：
   - 阶段1：实现基本功能（控制 + 状态查询）
   - 阶段2：优化性能（图像传输、网络延迟）
   - 阶段3：完善功能（错误处理、监控）

2. **测试策略**：
   - 先单机部署测试基本功能
   - 再双机部署测试网络通信
   - 最后进行完整训练测试

3. **文档和代码**：
   - 保持代码注释完整
   - 记录已知问题和解决方案
   - 定期更新文档
